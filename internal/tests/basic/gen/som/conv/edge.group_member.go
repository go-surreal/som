// Code generated by github.com/go-surreal/som, DO NOT EDIT.
package conv

import (
	v2 "github.com/fxamacker/cbor/v2"
	som "github.com/go-surreal/som/tests/basic/gen/som"
	cbor "github.com/go-surreal/som/tests/basic/gen/som/internal/cbor"
	types "github.com/go-surreal/som/tests/basic/gen/som/internal/types"
	model "github.com/go-surreal/som/tests/basic/model"
	"time"
)

type GroupMember struct {
	model.GroupMember
}

func (c *GroupMember) MarshalCBOR() ([]byte, error) {
	if c == nil {
		return cbor.Marshal(nil)
	}
	data := make(map[string]any, 4)

	// Embedded som.Node/Edge ID field
	if c.ID() != nil {
		data["id"] = c.ID()
	}

	// Embedded som.Timestamps field: CreatedAt
	if !c.CreatedAt().IsZero() {
		data["created_at"] = &types.DateTime{Time: c.CreatedAt()}
	}

	// Embedded som.Timestamps field: UpdatedAt
	if !c.UpdatedAt().IsZero() {
		data["updated_at"] = &types.DateTime{Time: c.UpdatedAt()}
	}

	// Regular fields
	{
		data["meta"] = fromGroupMemberMeta(c.Meta)
	}

	return cbor.Marshal(data)
}

func (c *GroupMember) UnmarshalCBOR(data []byte) error {
	var rawMap map[string]v2.RawMessage
	if err := cbor.Unmarshal(data, &rawMap); err != nil {
		return err
	}

	// Embedded som.Node/Edge ID field
	if raw, ok := rawMap["id"]; ok {
		var id *som.ID
		cbor.Unmarshal(raw, &id)
		c.Edge = som.NewEdge(id)
	}

	// Embedded som.Timestamps field: CreatedAt
	var createdAt time.Time
	if raw, ok := rawMap["created_at"]; ok {
		createdAt, _ = cbor.UnmarshalDateTime(raw)
	}

	// Embedded som.Timestamps field: UpdatedAt
	var updatedAt time.Time
	if raw, ok := rawMap["updated_at"]; ok {
		updatedAt, _ = cbor.UnmarshalDateTime(raw)
	}

	// Initialize Timestamps embedding
	createdAtDT := &types.DateTime{Time: createdAt}
	updatedAtDT := &types.DateTime{Time: updatedAt}
	c.Timestamps = som.NewTimestamps(createdAtDT, updatedAtDT)

	// Regular fields
	if raw, ok := rawMap["meta"]; ok {
		var convVal groupMemberMeta
		cbor.Unmarshal(raw, &convVal)
		c.Meta = toGroupMemberMeta(convVal)
	}

	return nil
}

func FromGroupMember(data model.GroupMember) GroupMember {
	return GroupMember{GroupMember: data}
}
func FromGroupMemberPtr(data *model.GroupMember) *GroupMember {
	if data == nil {
		return nil
	}
	return &GroupMember{GroupMember: *data}
}

func ToGroupMember(data *GroupMember) model.GroupMember {
	return data.GroupMember
}
func ToGroupMemberPtr(data *GroupMember) *model.GroupMember {
	if data == nil {
		return nil
	}
	result := data.GroupMember
	return &result
}
