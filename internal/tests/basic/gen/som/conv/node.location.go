// Code generated by github.com/go-surreal/som, DO NOT EDIT.
package conv

import (
	v2 "github.com/fxamacker/cbor/v2"
	som "github.com/go-surreal/som/tests/basic/gen/som"
	internal "github.com/go-surreal/som/tests/basic/gen/som/internal"
	cbor "github.com/go-surreal/som/tests/basic/gen/som/internal/cbor"
	types "github.com/go-surreal/som/tests/basic/gen/som/internal/types"
	model "github.com/go-surreal/som/tests/basic/model"
	models "github.com/surrealdb/surrealdb.go/pkg/models"
)

type Location struct {
	model.Location
}

func (c *Location) MarshalCBOR() ([]byte, error) {
	if c == nil {
		return cbor.Marshal(nil)
	}
	data := make(map[string]any, 25)

	// Embedded som.Node/Edge ID field
	if c.ID() != "" {
		data["id"] = models.NewRecordID("location", c.ID())
	}

	if !c.CreatedAt().IsZero() {
		data["created_at"] = &types.DateTime{Time: c.CreatedAt()}
	}
	if !c.UpdatedAt().IsZero() {
		data["updated_at"] = &types.DateTime{Time: c.UpdatedAt()}
	}
	data["name"] = c.Name
	{
		geoVal := types.PointOrb(c.Point)
		data["point"] = &geoVal
	}
	if c.PointPtr != nil {
		geoVal := types.PointOrb(*c.PointPtr)
		data["point_ptr"] = &geoVal
	}
	{
		geoVal := types.LineStringOrb(c.LineString)
		data["line_string"] = &geoVal
	}
	if c.LineStringPtr != nil {
		geoVal := types.LineStringOrb(*c.LineStringPtr)
		data["line_string_ptr"] = &geoVal
	}
	{
		geoVal := types.PolygonOrb(c.Polygon)
		data["polygon"] = &geoVal
	}
	if c.PolygonPtr != nil {
		geoVal := types.PolygonOrb(*c.PolygonPtr)
		data["polygon_ptr"] = &geoVal
	}
	{
		geoVal := types.MultiPointOrb(c.MultiPoint)
		data["multi_point"] = &geoVal
	}
	if c.MultiPointPtr != nil {
		geoVal := types.MultiPointOrb(*c.MultiPointPtr)
		data["multi_point_ptr"] = &geoVal
	}
	{
		geoVal := types.MultiLineStringOrb(c.MultiLineString)
		data["multi_line_string"] = &geoVal
	}
	{
		geoVal := types.MultiPolygonOrb(c.MultiPolygon)
		data["multi_polygon"] = &geoVal
	}
	{
		geoVal := types.CollectionOrb(c.Collection)
		data["collection"] = &geoVal
	}
	{
		geoVal := types.PointGG{c.GGPoint}
		data["gg_point"] = &geoVal
	}
	if c.GGPointPtr != nil {
		geoVal := types.PointGG{*c.GGPointPtr}
		data["gg_point_ptr"] = &geoVal
	}
	{
		geoVal := types.LineStringGG{c.GGLineString}
		data["gg_line_string"] = &geoVal
	}
	if c.GGLineStringPtr != nil {
		geoVal := types.LineStringGG{*c.GGLineStringPtr}
		data["gg_line_string_ptr"] = &geoVal
	}
	{
		geoVal := types.PolygonGG{c.GGPolygon}
		data["gg_polygon"] = &geoVal
	}
	if c.GGPolygonPtr != nil {
		geoVal := types.PolygonGG{*c.GGPolygonPtr}
		data["gg_polygon_ptr"] = &geoVal
	}
	{
		geoVal := types.MultiPointGG{c.GGMultiPoint}
		data["gg_multi_point"] = &geoVal
	}
	if c.GGMultiPointPtr != nil {
		geoVal := types.MultiPointGG{*c.GGMultiPointPtr}
		data["gg_multi_point_ptr"] = &geoVal
	}
	{
		geoVal := types.MultiLineStringGG{c.GGMultiLineString}
		data["gg_multi_line_string"] = &geoVal
	}
	{
		geoVal := types.MultiPolygonGG{c.GGMultiPolygon}
		data["gg_multi_polygon"] = &geoVal
	}

	return cbor.Marshal(data)
}

func (c *Location) UnmarshalCBOR(data []byte) error {
	var rawMap map[string]v2.RawMessage
	if err := cbor.Unmarshal(data, &rawMap); err != nil {
		return err
	}

	// Embedded som.Node/Edge ID field
	if raw, ok := rawMap["id"]; ok {
		var recordID *models.RecordID
		if err := cbor.Unmarshal(raw, &recordID); err != nil {
			return err
		}
		var idStr string
		if recordID != nil {
			s, err := cbor.RecordIDToString(recordID.ID)
			if err != nil {
				return err
			}
			idStr = s
		}
		c.Node = som.NewNode[som.ULID](som.ULID(idStr))
	}

	if raw, ok := rawMap["created_at"]; ok {
		tm, _ := cbor.UnmarshalDateTime(raw)
		internal.SetCreatedAt(&c.Timestamps, tm)
	}
	if raw, ok := rawMap["updated_at"]; ok {
		tm, _ := cbor.UnmarshalDateTime(raw)
		internal.SetUpdatedAt(&c.Timestamps, tm)
	}
	if raw, ok := rawMap["name"]; ok {
		cbor.Unmarshal(raw, &c.Name)
	}
	if raw, ok := rawMap["point"]; ok {
		c.Point, _ = cbor.UnmarshalPointOrb(raw)
	}
	if raw, ok := rawMap["point_ptr"]; ok {
		c.PointPtr, _ = cbor.UnmarshalPointOrbPtr(raw)
	}
	if raw, ok := rawMap["line_string"]; ok {
		c.LineString, _ = cbor.UnmarshalLineStringOrb(raw)
	}
	if raw, ok := rawMap["line_string_ptr"]; ok {
		c.LineStringPtr, _ = cbor.UnmarshalLineStringOrbPtr(raw)
	}
	if raw, ok := rawMap["polygon"]; ok {
		c.Polygon, _ = cbor.UnmarshalPolygonOrb(raw)
	}
	if raw, ok := rawMap["polygon_ptr"]; ok {
		c.PolygonPtr, _ = cbor.UnmarshalPolygonOrbPtr(raw)
	}
	if raw, ok := rawMap["multi_point"]; ok {
		c.MultiPoint, _ = cbor.UnmarshalMultiPointOrb(raw)
	}
	if raw, ok := rawMap["multi_point_ptr"]; ok {
		c.MultiPointPtr, _ = cbor.UnmarshalMultiPointOrbPtr(raw)
	}
	if raw, ok := rawMap["multi_line_string"]; ok {
		c.MultiLineString, _ = cbor.UnmarshalMultiLineStringOrb(raw)
	}
	if raw, ok := rawMap["multi_polygon"]; ok {
		c.MultiPolygon, _ = cbor.UnmarshalMultiPolygonOrb(raw)
	}
	if raw, ok := rawMap["collection"]; ok {
		c.Collection, _ = cbor.UnmarshalCollectionOrb(raw)
	}
	if raw, ok := rawMap["gg_point"]; ok {
		c.GGPoint, _ = cbor.UnmarshalPointGG(raw)
	}
	if raw, ok := rawMap["gg_point_ptr"]; ok {
		c.GGPointPtr, _ = cbor.UnmarshalPointGGPtr(raw)
	}
	if raw, ok := rawMap["gg_line_string"]; ok {
		c.GGLineString, _ = cbor.UnmarshalLineStringGG(raw)
	}
	if raw, ok := rawMap["gg_line_string_ptr"]; ok {
		c.GGLineStringPtr, _ = cbor.UnmarshalLineStringGGPtr(raw)
	}
	if raw, ok := rawMap["gg_polygon"]; ok {
		c.GGPolygon, _ = cbor.UnmarshalPolygonGG(raw)
	}
	if raw, ok := rawMap["gg_polygon_ptr"]; ok {
		c.GGPolygonPtr, _ = cbor.UnmarshalPolygonGGPtr(raw)
	}
	if raw, ok := rawMap["gg_multi_point"]; ok {
		c.GGMultiPoint, _ = cbor.UnmarshalMultiPointGG(raw)
	}
	if raw, ok := rawMap["gg_multi_point_ptr"]; ok {
		c.GGMultiPointPtr, _ = cbor.UnmarshalMultiPointGGPtr(raw)
	}
	if raw, ok := rawMap["gg_multi_line_string"]; ok {
		c.GGMultiLineString, _ = cbor.UnmarshalMultiLineStringGG(raw)
	}
	if raw, ok := rawMap["gg_multi_polygon"]; ok {
		c.GGMultiPolygon, _ = cbor.UnmarshalMultiPolygonGG(raw)
	}

	return nil
}

func FromLocation(data model.Location) Location {
	return Location{Location: data}
}
func FromLocationPtr(data *model.Location) *Location {
	if data == nil {
		return nil
	}
	return &Location{Location: *data}
}

func ToLocation(data Location) model.Location {
	return data.Location
}
func ToLocationPtr(data *Location) *model.Location {
	if data == nil {
		return nil
	}
	result := data.Location
	return &result
}

type locationLink struct {
	Location
	ID *models.RecordID
}

func (f *locationLink) MarshalCBOR() ([]byte, error) {
	if f == nil {
		return nil, nil
	}
	return cbor.Marshal(f.ID)
}

func (f *locationLink) UnmarshalCBOR(data []byte) error {
	if err := cbor.Unmarshal(data, &f.ID); err == nil {
		return nil
	}
	type alias locationLink
	var link alias
	err := cbor.Unmarshal(data, &link)
	if err == nil {
		*f = locationLink(link)
	}
	return err
}

func fromLocationLink(link *locationLink) model.Location {
	if link == nil {
		return model.Location{}
	}
	res := Location(link.Location)
	return ToLocation(res)
}

func fromLocationLinkPtr(link *locationLink) *model.Location {
	if link == nil {
		return nil
	}
	res := Location(link.Location)
	out := ToLocation(res)
	return &out
}

func toLocationLink(node model.Location) *locationLink {
	if node.ID() == "" {
		return nil
	}
	rid := models.NewRecordID("location", node.ID())
	link := locationLink{Location: FromLocation(node), ID: &rid}
	return &link
}

func toLocationLinkPtr(node *model.Location) *locationLink {
	if node == nil {
		return nil
	}
	if node.ID() == "" {
		return nil
	}
	rid := models.NewRecordID("location", node.ID())
	link := locationLink{Location: FromLocation(*node), ID: &rid}
	return &link
}
