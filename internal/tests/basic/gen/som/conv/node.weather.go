// Code generated by github.com/go-surreal/som, DO NOT EDIT.
package conv

import (
	v2 "github.com/fxamacker/cbor/v2"
	som "github.com/go-surreal/som/tests/basic/gen/som"
	cbor "github.com/go-surreal/som/tests/basic/gen/som/internal/cbor"
	types "github.com/go-surreal/som/tests/basic/gen/som/internal/types"
	model "github.com/go-surreal/som/tests/basic/model"
	models "github.com/surrealdb/surrealdb.go/pkg/models"
)

type Weather struct {
	model.Weather
}

func (c *Weather) MarshalCBOR() ([]byte, error) {
	if c == nil {
		return cbor.Marshal(nil)
	}
	data := make(map[string]any, 1)

	// Embedded som.Node/Edge ID field

	data["temperature"] = c.Temperature

	return cbor.Marshal(data)
}

func (c *Weather) UnmarshalCBOR(data []byte) error {
	var rawMap map[string]v2.RawMessage
	if err := cbor.Unmarshal(data, &rawMap); err != nil {
		return err
	}

	// Embedded som.Node/Edge ID field
	if raw, ok := rawMap["id"]; ok {
		var recordID *models.RecordID
		if err := cbor.Unmarshal(raw, &recordID); err != nil {
			return err
		}
		if recordID != nil {
			idRaw, err := cbor.Marshal(recordID.ID)
			if err != nil {
				return err
			}
			{
				var rawArr []v2.RawMessage
				if err := cbor.Unmarshal(idRaw, &rawArr); err != nil {
					return err
				}
				if len(rawArr) >= 2 {
					var key model.WeatherKey
					if err := cbor.Unmarshal(rawArr[0], &key.City); err != nil {
						return err
					}
					{
						var DateErr error
						key.Date, DateErr = cbor.UnmarshalDateTime(rawArr[1])
						if DateErr != nil {
							return DateErr
						}
					}
					c.CustomNode = som.NewCustomNode[model.WeatherKey](key)
				}
			}
		}
	}

	if raw, ok := rawMap["temperature"]; ok {
		cbor.Unmarshal(raw, &c.Temperature)
	}

	return nil
}

func FromWeather(data model.Weather) Weather {
	return Weather{Weather: data}
}
func FromWeatherPtr(data *model.Weather) *Weather {
	if data == nil {
		return nil
	}
	return &Weather{Weather: *data}
}

func ToWeather(data Weather) model.Weather {
	return data.Weather
}
func ToWeatherPtr(data *Weather) *model.Weather {
	if data == nil {
		return nil
	}
	result := data.Weather
	return &result
}

type weatherLink struct {
	Weather
	ID *models.RecordID
}

func (f *weatherLink) MarshalCBOR() ([]byte, error) {
	if f == nil {
		return nil, nil
	}
	return cbor.Marshal(f.ID)
}

func (f *weatherLink) UnmarshalCBOR(data []byte) error {
	if err := cbor.Unmarshal(data, &f.ID); err == nil {
		return nil
	}
	type alias weatherLink
	var link alias
	err := cbor.Unmarshal(data, &link)
	if err == nil {
		*f = weatherLink(link)
	}
	return err
}

func fromWeatherLink(link *weatherLink) model.Weather {
	if link == nil {
		return model.Weather{}
	}
	res := Weather(link.Weather)
	return ToWeather(res)
}

func fromWeatherLinkPtr(link *weatherLink) *model.Weather {
	if link == nil {
		return nil
	}
	res := Weather(link.Weather)
	out := ToWeather(res)
	return &out
}

func toWeatherLink(node model.Weather) *weatherLink {
	var zeroKey model.WeatherKey
	if node.ID() == zeroKey {
		return nil
	}
	rid := models.NewRecordID("weather", []any{node.ID().City, &types.DateTime{Time: node.ID().Date}})
	link := weatherLink{Weather: FromWeather(node), ID: &rid}
	return &link
}

func toWeatherLinkPtr(node *model.Weather) *weatherLink {
	if node == nil {
		return nil
	}
	var zeroKey model.WeatherKey
	if node.ID() == zeroKey {
		return nil
	}
	rid := models.NewRecordID("weather", []any{node.ID().City, &types.DateTime{Time: node.ID().Date}})
	link := weatherLink{Weather: FromWeather(*node), ID: &rid}
	return &link
}
