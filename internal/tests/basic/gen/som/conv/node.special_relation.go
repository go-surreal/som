// Code generated by github.com/go-surreal/som, DO NOT EDIT.
package conv

import (
	v2 "github.com/fxamacker/cbor/v2"
	som "github.com/go-surreal/som/tests/basic/gen/som"
	internal "github.com/go-surreal/som/tests/basic/gen/som/internal"
	cbor "github.com/go-surreal/som/tests/basic/gen/som/internal/cbor"
	types "github.com/go-surreal/som/tests/basic/gen/som/internal/types"
	model "github.com/go-surreal/som/tests/basic/model"
	models "github.com/surrealdb/surrealdb.go/pkg/models"
)

type SpecialRelation struct {
	model.SpecialRelation
}

func (c *SpecialRelation) MarshalCBOR() ([]byte, error) {
	if c == nil {
		return cbor.Marshal(nil)
	}
	data := make(map[string]any, 5)

	// Embedded som.Node/Edge ID field
	if c.ID() != "" {
		data["id"] = models.NewRecordID("special_relation", c.ID())
	}

	if c.SoftDelete.IsDeleted() {
		data["deleted_at"] = &types.DateTime{Time: c.SoftDelete.DeletedAt()}
	}
	data["title"] = c.Title
	if c.Author != nil {
		data["author"] = toSpecialTypesLinkPtr(c.Author)
	}
	if c.Authors != nil {
		convSlice := make([]*specialTypesLink, 0, len(c.Authors))
		for _, v := range c.Authors {
			if link := toSpecialTypesLinkPtr(v); link != nil {
				convSlice = append(convSlice, link)
			}
		}
		data["authors"] = convSlice
	}

	return cbor.Marshal(data)
}

func (c *SpecialRelation) UnmarshalCBOR(data []byte) error {
	var rawMap map[string]v2.RawMessage
	if err := cbor.Unmarshal(data, &rawMap); err != nil {
		return err
	}

	// Embedded som.Node/Edge ID field
	if raw, ok := rawMap["id"]; ok {
		var recordID *models.RecordID
		if err := cbor.Unmarshal(raw, &recordID); err != nil {
			return err
		}
		var idStr string
		if recordID != nil {
			s, err := cbor.RecordIDToString(recordID.ID)
			if err != nil {
				return err
			}
			idStr = s
		}
		c.CustomNode = som.NewCustomNode[som.Rand](som.Rand(idStr))
	}

	if raw, ok := rawMap["deleted_at"]; ok {
		tm, _ := cbor.UnmarshalDateTime(raw)
		internal.SetDeletedAt(&c.SoftDelete, tm)
	}
	if raw, ok := rawMap["title"]; ok {
		cbor.Unmarshal(raw, &c.Title)
	}
	if raw, ok := rawMap["author"]; ok {
		var convVal *specialTypesLink
		cbor.Unmarshal(raw, &convVal)
		c.Author = fromSpecialTypesLinkPtr(convVal)
	}
	if raw, ok := rawMap["authors"]; ok {
		var convSlice []*specialTypesLink
		cbor.Unmarshal(raw, &convSlice)
		{
			c.Authors = make([]*model.SpecialTypes, len(convSlice))
			for i, v := range convSlice {
				c.Authors[i] = fromSpecialTypesLinkPtr(v)
			}
		}
	}

	return nil
}

func FromSpecialRelation(data model.SpecialRelation) SpecialRelation {
	return SpecialRelation{SpecialRelation: data}
}
func FromSpecialRelationPtr(data *model.SpecialRelation) *SpecialRelation {
	if data == nil {
		return nil
	}
	return &SpecialRelation{SpecialRelation: *data}
}

func ToSpecialRelation(data SpecialRelation) model.SpecialRelation {
	return data.SpecialRelation
}
func ToSpecialRelationPtr(data *SpecialRelation) *model.SpecialRelation {
	if data == nil {
		return nil
	}
	result := data.SpecialRelation
	return &result
}

type specialRelationLink struct {
	SpecialRelation
	ID *models.RecordID
}

func (f *specialRelationLink) MarshalCBOR() ([]byte, error) {
	if f == nil {
		return nil, nil
	}
	return cbor.Marshal(f.ID)
}

func (f *specialRelationLink) UnmarshalCBOR(data []byte) error {
	if err := cbor.Unmarshal(data, &f.ID); err == nil {
		return nil
	}
	type alias specialRelationLink
	var link alias
	err := cbor.Unmarshal(data, &link)
	if err == nil {
		*f = specialRelationLink(link)
	}
	return err
}

func fromSpecialRelationLink(link *specialRelationLink) model.SpecialRelation {
	if link == nil {
		return model.SpecialRelation{}
	}
	res := SpecialRelation(link.SpecialRelation)
	return ToSpecialRelation(res)
}

func fromSpecialRelationLinkPtr(link *specialRelationLink) *model.SpecialRelation {
	if link == nil {
		return nil
	}
	res := SpecialRelation(link.SpecialRelation)
	out := ToSpecialRelation(res)
	return &out
}

func toSpecialRelationLink(node model.SpecialRelation) *specialRelationLink {
	if node.ID() == "" {
		return nil
	}
	rid := models.NewRecordID("special_relation", node.ID())
	link := specialRelationLink{SpecialRelation: FromSpecialRelation(node), ID: &rid}
	return &link
}

func toSpecialRelationLinkPtr(node *model.SpecialRelation) *specialRelationLink {
	if node == nil {
		return nil
	}
	if node.ID() == "" {
		return nil
	}
	rid := models.NewRecordID("special_relation", node.ID())
	link := specialRelationLink{SpecialRelation: FromSpecialRelation(*node), ID: &rid}
	return &link
}
