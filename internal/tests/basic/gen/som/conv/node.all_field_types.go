// Code generated by github.com/go-surreal/som, DO NOT EDIT.
package conv

import (
	v2 "github.com/fxamacker/cbor/v2"
	som "github.com/go-surreal/som/tests/basic/gen/som"
	cbor "github.com/go-surreal/som/tests/basic/gen/som/internal/cbor"
	types "github.com/go-surreal/som/tests/basic/gen/som/internal/types"
	model "github.com/go-surreal/som/tests/basic/model"
)

type AllFieldTypes struct {
	model.AllFieldTypes
}

func (c *AllFieldTypes) MarshalCBOR() ([]byte, error) {
	if c == nil {
		return cbor.Marshal(nil)
	}
	data := make(map[string]any, 82)

	// Embedded som.Node/Edge ID field
	if c.ID() != nil {
		data["id"] = c.ID()
	}

	if !c.CreatedAt().IsZero() {
		data["created_at"] = &types.DateTime{Time: c.CreatedAt()}
	}
	if !c.UpdatedAt().IsZero() {
		data["updated_at"] = &types.DateTime{Time: c.UpdatedAt()}
	}
	data["string"] = c.String
	if c.StringPtr != nil {
		data["string_ptr"] = c.StringPtr
	}
	if c.Other != nil {
		data["other"] = c.Other
	}
	if c.StringPtrSlice != nil {
		data["string_ptr_slice"] = c.StringPtrSlice
	}
	if c.StringSlicePtr != nil {
		data["string_slice_ptr"] = c.StringSlicePtr
	}
	data["int"] = c.Int
	if c.IntPtr != nil {
		data["int_ptr"] = c.IntPtr
	}
	if c.IntSlice != nil {
		data["int_slice"] = c.IntSlice
	}
	if c.IntPtrSlice != nil {
		data["int_ptr_slice"] = c.IntPtrSlice
	}
	if c.IntSlicePtr != nil {
		data["int_slice_ptr"] = c.IntSlicePtr
	}
	if c.IntPtrSlicePtr != nil {
		data["int_ptr_slice_ptr"] = c.IntPtrSlicePtr
	}
	data["int_8"] = c.Int8
	if c.Int8Ptr != nil {
		data["int_8_ptr"] = c.Int8Ptr
	}
	data["int_16"] = c.Int16
	if c.Int16Ptr != nil {
		data["int_16_ptr"] = c.Int16Ptr
	}
	data["int_32"] = c.Int32
	if c.Int32Ptr != nil {
		data["int_32_ptr"] = c.Int32Ptr
	}
	data["int_64"] = c.Int64
	if c.Int64Ptr != nil {
		data["int_64_ptr"] = c.Int64Ptr
	}
	data["uint_8"] = c.Uint8
	if c.Uint8Ptr != nil {
		data["uint_8_ptr"] = c.Uint8Ptr
	}
	data["uint_16"] = c.Uint16
	if c.Uint16Ptr != nil {
		data["uint_16_ptr"] = c.Uint16Ptr
	}
	data["uint_32"] = c.Uint32
	if c.Uint32Ptr != nil {
		data["uint_32_ptr"] = c.Uint32Ptr
	}
	data["float_32"] = c.Float32
	if c.Float32Slice != nil {
		data["float_32_slice"] = c.Float32Slice
	}
	if c.Float32SlicePtr != nil {
		data["float_32_slice_ptr"] = c.Float32SlicePtr
	}
	if c.Float32PtrSlice != nil {
		data["float_32_ptr_slice"] = c.Float32PtrSlice
	}
	if c.Float32PtrSlicePtr != nil {
		data["float_32_ptr_slice_ptr"] = c.Float32PtrSlicePtr
	}
	data["float_64"] = c.Float64
	data["rune"] = c.Rune
	if c.RuneSlice != nil {
		data["rune_slice"] = c.RuneSlice
	}
	data["bool"] = c.Bool
	if c.BoolPtr != nil {
		data["bool_ptr"] = c.BoolPtr
	}
	if c.BoolSlice != nil {
		data["bool_slice"] = c.BoolSlice
	}
	data["time"] = &types.DateTime{Time: c.Time}
	if c.TimePtr != nil {
		data["time_ptr"] = &types.DateTime{Time: *c.TimePtr}
	}
	if c.TimeNil != nil {
		data["time_nil"] = &types.DateTime{Time: *c.TimeNil}
	}
	if c.TimeSlice != nil {
		data["time_slice"] = c.TimeSlice
	}
	if c.TimeSliceSlice != nil {
		data["time_slice_slice"] = c.TimeSliceSlice
	}
	data["duration"] = &types.Duration{Duration: c.Duration}
	if c.DurationPtr != nil {
		data["duration_ptr"] = &types.Duration{Duration: *c.DurationPtr}
	}
	if c.DurationNil != nil {
		data["duration_nil"] = &types.Duration{Duration: *c.DurationNil}
	}
	if c.DurationSlice != nil {
		data["duration_slice"] = c.DurationSlice
	}
	{
		uuidVal := types.UUID(c.UUID)
		data["uuid"] = &uuidVal
	}
	if c.UUIDPtr != nil {
		uuidVal := types.UUID(*c.UUIDPtr)
		data["uuid_ptr"] = &uuidVal
	}
	if c.UUIDNil != nil {
		uuidVal := types.UUID(*c.UUIDNil)
		data["uuid_nil"] = &uuidVal
	}
	if c.UUIDSlice != nil {
		data["uuid_slice"] = c.UUIDSlice
	}
	data["url"] = fromURL(c.URL)
	if c.URLPtr != nil {
		data["url_ptr"] = fromURLPtr(c.URLPtr)
	}
	if c.URLNil != nil {
		data["url_nil"] = fromURLPtr(c.URLNil)
	}
	if c.URLSlice != nil {
		data["url_slice"] = c.URLSlice
	}
	data["role"] = c.Role
	if c.EnumPtr != nil {
		data["enum_ptr"] = c.EnumPtr
	}
	if c.Roles != nil {
		data["roles"] = c.Roles
	}
	if c.EnumPtrSlice != nil {
		data["enum_ptr_slice"] = c.EnumPtrSlice
	}
	if c.EnumPtrSlicePtr != nil {
		data["enum_ptr_slice_ptr"] = c.EnumPtrSlicePtr
	}
	data["login"] = fromLogin(c.Login)
	if c.StructPtr != nil {
		data["struct_ptr"] = fromSomeStructPtr(c.StructPtr)
	}
	if c.StructSlice != nil {
		convSlice := make([]someStruct, len(c.StructSlice))
		for i, v := range c.StructSlice {
			convSlice[i] = fromSomeStruct(v)
		}
		data["struct_slice"] = convSlice
	}
	if c.StructPtrSlice != nil {
		convSlice := make([]*someStruct, len(c.StructPtrSlice))
		for i, v := range c.StructPtrSlice {
			convSlice[i] = fromSomeStructPtr(v)
		}
		data["struct_ptr_slice"] = convSlice
	}
	if c.StructPtrSlicePtr != nil {
		convSlice := make([]*someStruct, len(*c.StructPtrSlicePtr))
		for i, v := range *c.StructPtrSlicePtr {
			convSlice[i] = fromSomeStructPtr(v)
		}
		data["struct_ptr_slice_ptr"] = convSlice
	}
	if link := toGroupLink(c.MainGroup); link != nil {
		data["main_group"] = link
	}
	if c.MainGroupPtr != nil {
		data["main_group_ptr"] = toGroupLinkPtr(c.MainGroupPtr)
	}
	if c.Groups != nil {
		data["groups"] = c.Groups
	}
	if c.GroupsSlice != nil {
		data["groups_slice"] = c.GroupsSlice
	}
	if c.NodePtrSlice != nil {
		data["node_ptr_slice"] = c.NodePtrSlice
	}
	if c.NodePtrSlicePtr != nil {
		data["node_ptr_slice_ptr"] = c.NodePtrSlicePtr
	}
	if c.MemberOf != nil {
		data["member_of"] = c.MemberOf
	}
	if c.SliceSlice != nil {
		data["slice_slice"] = c.SliceSlice
	}
	if c.SliceSliceSlice != nil {
		data["slice_slice_slice"] = c.SliceSliceSlice
	}
	if c.SliceSliceSlice2 != nil {
		data["slice_slice_slice_2"] = c.SliceSliceSlice2
	}
	data["byte"] = c.Byte
	if c.BytePtr != nil {
		data["byte_ptr"] = c.BytePtr
	}
	if c.ByteSlice != nil {
		data["byte_slice"] = c.ByteSlice
	}
	if c.ByteSlicePtr != nil {
		data["byte_slice_ptr"] = c.ByteSlicePtr
	}
	data["password"] = c.Password
	if c.PasswordPtr != nil {
		data["password_ptr"] = c.PasswordPtr
	}

	return cbor.Marshal(data)
}

func (c *AllFieldTypes) UnmarshalCBOR(data []byte) error {
	var rawMap map[string]v2.RawMessage
	if err := cbor.Unmarshal(data, &rawMap); err != nil {
		return err
	}

	// Embedded som.Node/Edge ID field
	if raw, ok := rawMap["id"]; ok {
		var id *som.ID
		cbor.Unmarshal(raw, &id)
		c.Node = som.NewNode(id)
	}

	if raw, ok := rawMap["created_at"]; ok {
		tm, _ := cbor.UnmarshalDateTime(raw)
		c.Timestamps.SetCreatedAt(tm)
	}
	if raw, ok := rawMap["updated_at"]; ok {
		tm, _ := cbor.UnmarshalDateTime(raw)
		c.Timestamps.SetUpdatedAt(tm)
	}
	if raw, ok := rawMap["string"]; ok {
		cbor.Unmarshal(raw, &c.String)
	}
	if raw, ok := rawMap["string_ptr"]; ok {
		cbor.Unmarshal(raw, &c.StringPtr)
	}
	if raw, ok := rawMap["other"]; ok {
		cbor.Unmarshal(raw, &c.Other)
	}
	if raw, ok := rawMap["string_ptr_slice"]; ok {
		cbor.Unmarshal(raw, &c.StringPtrSlice)
	}
	if raw, ok := rawMap["string_slice_ptr"]; ok {
		cbor.Unmarshal(raw, &c.StringSlicePtr)
	}
	if raw, ok := rawMap["int"]; ok {
		cbor.Unmarshal(raw, &c.Int)
	}
	if raw, ok := rawMap["int_ptr"]; ok {
		cbor.Unmarshal(raw, &c.IntPtr)
	}
	if raw, ok := rawMap["int_slice"]; ok {
		cbor.Unmarshal(raw, &c.IntSlice)
	}
	if raw, ok := rawMap["int_ptr_slice"]; ok {
		cbor.Unmarshal(raw, &c.IntPtrSlice)
	}
	if raw, ok := rawMap["int_slice_ptr"]; ok {
		cbor.Unmarshal(raw, &c.IntSlicePtr)
	}
	if raw, ok := rawMap["int_ptr_slice_ptr"]; ok {
		cbor.Unmarshal(raw, &c.IntPtrSlicePtr)
	}
	if raw, ok := rawMap["int_8"]; ok {
		cbor.Unmarshal(raw, &c.Int8)
	}
	if raw, ok := rawMap["int_8_ptr"]; ok {
		cbor.Unmarshal(raw, &c.Int8Ptr)
	}
	if raw, ok := rawMap["int_16"]; ok {
		cbor.Unmarshal(raw, &c.Int16)
	}
	if raw, ok := rawMap["int_16_ptr"]; ok {
		cbor.Unmarshal(raw, &c.Int16Ptr)
	}
	if raw, ok := rawMap["int_32"]; ok {
		cbor.Unmarshal(raw, &c.Int32)
	}
	if raw, ok := rawMap["int_32_ptr"]; ok {
		cbor.Unmarshal(raw, &c.Int32Ptr)
	}
	if raw, ok := rawMap["int_64"]; ok {
		cbor.Unmarshal(raw, &c.Int64)
	}
	if raw, ok := rawMap["int_64_ptr"]; ok {
		cbor.Unmarshal(raw, &c.Int64Ptr)
	}
	if raw, ok := rawMap["uint_8"]; ok {
		cbor.Unmarshal(raw, &c.Uint8)
	}
	if raw, ok := rawMap["uint_8_ptr"]; ok {
		cbor.Unmarshal(raw, &c.Uint8Ptr)
	}
	if raw, ok := rawMap["uint_16"]; ok {
		cbor.Unmarshal(raw, &c.Uint16)
	}
	if raw, ok := rawMap["uint_16_ptr"]; ok {
		cbor.Unmarshal(raw, &c.Uint16Ptr)
	}
	if raw, ok := rawMap["uint_32"]; ok {
		cbor.Unmarshal(raw, &c.Uint32)
	}
	if raw, ok := rawMap["uint_32_ptr"]; ok {
		cbor.Unmarshal(raw, &c.Uint32Ptr)
	}
	if raw, ok := rawMap["float_32"]; ok {
		cbor.Unmarshal(raw, &c.Float32)
	}
	if raw, ok := rawMap["float_32_slice"]; ok {
		cbor.Unmarshal(raw, &c.Float32Slice)
	}
	if raw, ok := rawMap["float_32_slice_ptr"]; ok {
		cbor.Unmarshal(raw, &c.Float32SlicePtr)
	}
	if raw, ok := rawMap["float_32_ptr_slice"]; ok {
		cbor.Unmarshal(raw, &c.Float32PtrSlice)
	}
	if raw, ok := rawMap["float_32_ptr_slice_ptr"]; ok {
		cbor.Unmarshal(raw, &c.Float32PtrSlicePtr)
	}
	if raw, ok := rawMap["float_64"]; ok {
		cbor.Unmarshal(raw, &c.Float64)
	}
	if raw, ok := rawMap["rune"]; ok {
		cbor.Unmarshal(raw, &c.Rune)
	}
	if raw, ok := rawMap["rune_slice"]; ok {
		cbor.Unmarshal(raw, &c.RuneSlice)
	}
	if raw, ok := rawMap["bool"]; ok {
		cbor.Unmarshal(raw, &c.Bool)
	}
	if raw, ok := rawMap["bool_ptr"]; ok {
		cbor.Unmarshal(raw, &c.BoolPtr)
	}
	if raw, ok := rawMap["bool_slice"]; ok {
		cbor.Unmarshal(raw, &c.BoolSlice)
	}
	if raw, ok := rawMap["time"]; ok {
		c.Time, _ = cbor.UnmarshalDateTime(raw)
	}
	if raw, ok := rawMap["time_ptr"]; ok {
		c.TimePtr, _ = cbor.UnmarshalDateTimePtr(raw)
	}
	if raw, ok := rawMap["time_nil"]; ok {
		c.TimeNil, _ = cbor.UnmarshalDateTimePtr(raw)
	}
	if raw, ok := rawMap["time_slice"]; ok {
		cbor.Unmarshal(raw, &c.TimeSlice)
	}
	if raw, ok := rawMap["time_slice_slice"]; ok {
		cbor.Unmarshal(raw, &c.TimeSliceSlice)
	}
	if raw, ok := rawMap["duration"]; ok {
		c.Duration, _ = cbor.UnmarshalDuration(raw)
	}
	if raw, ok := rawMap["duration_ptr"]; ok {
		c.DurationPtr, _ = cbor.UnmarshalDurationPtr(raw)
	}
	if raw, ok := rawMap["duration_nil"]; ok {
		c.DurationNil, _ = cbor.UnmarshalDurationPtr(raw)
	}
	if raw, ok := rawMap["duration_slice"]; ok {
		cbor.Unmarshal(raw, &c.DurationSlice)
	}
	if raw, ok := rawMap["uuid"]; ok {
		c.UUID, _ = cbor.UnmarshalUUID(raw)
	}
	if raw, ok := rawMap["uuid_ptr"]; ok {
		c.UUIDPtr, _ = cbor.UnmarshalUUIDPtr(raw)
	}
	if raw, ok := rawMap["uuid_nil"]; ok {
		c.UUIDNil, _ = cbor.UnmarshalUUIDPtr(raw)
	}
	if raw, ok := rawMap["uuid_slice"]; ok {
		cbor.Unmarshal(raw, &c.UUIDSlice)
	}
	if raw, ok := rawMap["url"]; ok {
		var convVal string
		cbor.Unmarshal(raw, &convVal)
		c.URL = toURL(convVal)
	}
	if raw, ok := rawMap["url_ptr"]; ok {
		var convVal *string
		cbor.Unmarshal(raw, &convVal)
		c.URLPtr = toURLPtr(convVal)
	}
	if raw, ok := rawMap["url_nil"]; ok {
		var convVal *string
		cbor.Unmarshal(raw, &convVal)
		c.URLNil = toURLPtr(convVal)
	}
	if raw, ok := rawMap["url_slice"]; ok {
		cbor.Unmarshal(raw, &c.URLSlice)
	}
	if raw, ok := rawMap["role"]; ok {
		cbor.Unmarshal(raw, &c.Role)
	}
	if raw, ok := rawMap["enum_ptr"]; ok {
		cbor.Unmarshal(raw, &c.EnumPtr)
	}
	if raw, ok := rawMap["roles"]; ok {
		cbor.Unmarshal(raw, &c.Roles)
	}
	if raw, ok := rawMap["enum_ptr_slice"]; ok {
		cbor.Unmarshal(raw, &c.EnumPtrSlice)
	}
	if raw, ok := rawMap["enum_ptr_slice_ptr"]; ok {
		cbor.Unmarshal(raw, &c.EnumPtrSlicePtr)
	}
	if raw, ok := rawMap["login"]; ok {
		var convVal login
		cbor.Unmarshal(raw, &convVal)
		c.Login = toLogin(convVal)
	}
	if raw, ok := rawMap["struct_ptr"]; ok {
		var convVal *someStruct
		cbor.Unmarshal(raw, &convVal)
		c.StructPtr = toSomeStructPtr(convVal)
	}
	if raw, ok := rawMap["struct_slice"]; ok {
		var convSlice []someStruct
		cbor.Unmarshal(raw, &convSlice)
		{
			c.StructSlice = make([]model.SomeStruct, len(convSlice))
			for i, v := range convSlice {
				c.StructSlice[i] = toSomeStruct(v)
			}
		}
	}
	if raw, ok := rawMap["struct_ptr_slice"]; ok {
		var convSlice []*someStruct
		cbor.Unmarshal(raw, &convSlice)
		{
			c.StructPtrSlice = make([]*model.SomeStruct, len(convSlice))
			for i, v := range convSlice {
				c.StructPtrSlice[i] = toSomeStructPtr(v)
			}
		}
	}
	if raw, ok := rawMap["struct_ptr_slice_ptr"]; ok {
		var convSlice []*someStruct
		cbor.Unmarshal(raw, &convSlice)
		{
			result := make([]*model.SomeStruct, len(convSlice))
			for i, v := range convSlice {
				result[i] = toSomeStructPtr(v)
			}
			c.StructPtrSlicePtr = &result
		}
	}
	if raw, ok := rawMap["main_group"]; ok {
		var convVal *groupLink
		cbor.Unmarshal(raw, &convVal)
		c.MainGroup = fromGroupLink(convVal)
	}
	if raw, ok := rawMap["main_group_ptr"]; ok {
		var convVal *groupLink
		cbor.Unmarshal(raw, &convVal)
		c.MainGroupPtr = fromGroupLinkPtr(convVal)
	}
	if raw, ok := rawMap["groups"]; ok {
		cbor.Unmarshal(raw, &c.Groups)
	}
	if raw, ok := rawMap["groups_slice"]; ok {
		cbor.Unmarshal(raw, &c.GroupsSlice)
	}
	if raw, ok := rawMap["node_ptr_slice"]; ok {
		cbor.Unmarshal(raw, &c.NodePtrSlice)
	}
	if raw, ok := rawMap["node_ptr_slice_ptr"]; ok {
		cbor.Unmarshal(raw, &c.NodePtrSlicePtr)
	}
	if raw, ok := rawMap["member_of"]; ok {
		cbor.Unmarshal(raw, &c.MemberOf)
	}
	if raw, ok := rawMap["slice_slice"]; ok {
		cbor.Unmarshal(raw, &c.SliceSlice)
	}
	if raw, ok := rawMap["slice_slice_slice"]; ok {
		cbor.Unmarshal(raw, &c.SliceSliceSlice)
	}
	if raw, ok := rawMap["slice_slice_slice_2"]; ok {
		cbor.Unmarshal(raw, &c.SliceSliceSlice2)
	}
	if raw, ok := rawMap["byte"]; ok {
		cbor.Unmarshal(raw, &c.Byte)
	}
	if raw, ok := rawMap["byte_ptr"]; ok {
		cbor.Unmarshal(raw, &c.BytePtr)
	}
	if raw, ok := rawMap["byte_slice"]; ok {
		cbor.Unmarshal(raw, &c.ByteSlice)
	}
	if raw, ok := rawMap["byte_slice_ptr"]; ok {
		cbor.Unmarshal(raw, &c.ByteSlicePtr)
	}
	if raw, ok := rawMap["password"]; ok {
		cbor.Unmarshal(raw, &c.Password)
	}
	if raw, ok := rawMap["password_ptr"]; ok {
		cbor.Unmarshal(raw, &c.PasswordPtr)
	}

	return nil
}

func FromAllFieldTypes(data model.AllFieldTypes) AllFieldTypes {
	return AllFieldTypes{AllFieldTypes: data}
}
func FromAllFieldTypesPtr(data *model.AllFieldTypes) *AllFieldTypes {
	if data == nil {
		return nil
	}
	return &AllFieldTypes{AllFieldTypes: *data}
}

func ToAllFieldTypes(data AllFieldTypes) model.AllFieldTypes {
	return data.AllFieldTypes
}
func ToAllFieldTypesPtr(data *AllFieldTypes) *model.AllFieldTypes {
	if data == nil {
		return nil
	}
	result := data.AllFieldTypes
	return &result
}

type allFieldTypesLink struct {
	AllFieldTypes
	ID *som.ID
}

func (f *allFieldTypesLink) MarshalCBOR() ([]byte, error) {
	if f == nil {
		return nil, nil
	}
	return cbor.Marshal(f.ID)
}

func (f *allFieldTypesLink) UnmarshalCBOR(data []byte) error {
	if err := cbor.Unmarshal(data, &f.ID); err == nil {
		return nil
	}
	type alias allFieldTypesLink
	var link alias
	err := cbor.Unmarshal(data, &link)
	if err == nil {
		*f = allFieldTypesLink(link)
	}
	return err
}

func fromAllFieldTypesLink(link *allFieldTypesLink) model.AllFieldTypes {
	if link == nil {
		return model.AllFieldTypes{}
	}
	res := AllFieldTypes(link.AllFieldTypes)
	return ToAllFieldTypes(res)
}

func fromAllFieldTypesLinkPtr(link *allFieldTypesLink) *model.AllFieldTypes {
	if link == nil {
		return nil
	}
	res := AllFieldTypes(link.AllFieldTypes)
	out := ToAllFieldTypes(res)
	return &out
}

func toAllFieldTypesLink(node model.AllFieldTypes) *allFieldTypesLink {
	if node.ID() == nil {
		return nil
	}
	link := allFieldTypesLink{AllFieldTypes: FromAllFieldTypes(node), ID: node.ID()}
	return &link
}

func toAllFieldTypesLinkPtr(node *model.AllFieldTypes) *allFieldTypesLink {
	if node == nil || node.ID() == nil {
		return nil
	}
	link := allFieldTypesLink{AllFieldTypes: FromAllFieldTypes(*node), ID: node.ID()}
	return &link
}
