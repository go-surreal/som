// Code generated by github.com/go-surreal/som, DO NOT EDIT.
package conv

import (
	v2 "github.com/fxamacker/cbor/v2"
	som "github.com/go-surreal/som/tests/basic/gen/som"
	cbor "github.com/go-surreal/som/tests/basic/gen/som/internal/cbor"
	types "github.com/go-surreal/som/tests/basic/gen/som/internal/types"
	model "github.com/go-surreal/som/tests/basic/model"
)

type SoftDeleteComplete struct {
	model.SoftDeleteComplete
}

func (c *SoftDeleteComplete) MarshalCBOR() ([]byte, error) {
	if c == nil {
		return cbor.Marshal(nil)
	}
	data := make(map[string]any, 6)

	// Embedded som.Node/Edge ID field
	if c.ID() != nil {
		data["id"] = c.ID()
	}

	if !c.CreatedAt().IsZero() {
		data["created_at"] = &types.DateTime{Time: c.CreatedAt()}
	}
	if !c.UpdatedAt().IsZero() {
		data["updated_at"] = &types.DateTime{Time: c.UpdatedAt()}
	}
	if c.SoftDelete.DeletedAt != nil {
		data["deleted_at"] = &types.DateTime{Time: *c.SoftDelete.DeletedAt}
	}
	data["name"] = c.Name
	data["__som_lock_version"] = c.Version()

	return cbor.Marshal(data)
}

func (c *SoftDeleteComplete) UnmarshalCBOR(data []byte) error {
	var rawMap map[string]v2.RawMessage
	if err := cbor.Unmarshal(data, &rawMap); err != nil {
		return err
	}

	// Embedded som.Node/Edge ID field
	if raw, ok := rawMap["id"]; ok {
		var id *som.ID
		cbor.Unmarshal(raw, &id)
		c.Node = som.NewNode(id)
	}

	if raw, ok := rawMap["created_at"]; ok {
		tm, _ := cbor.UnmarshalDateTime(raw)
		c.Timestamps.SetCreatedAt(tm)
	}
	if raw, ok := rawMap["updated_at"]; ok {
		tm, _ := cbor.UnmarshalDateTime(raw)
		c.Timestamps.SetUpdatedAt(tm)
	}
	if raw, ok := rawMap["deleted_at"]; ok {
		c.SoftDelete.DeletedAt, _ = cbor.UnmarshalDateTimePtr(raw)
	}
	if raw, ok := rawMap["name"]; ok {
		cbor.Unmarshal(raw, &c.Name)
	}
	if raw, ok := rawMap["__som_lock_version"]; ok {
		var v int
		cbor.Unmarshal(raw, &v)
		c.OptimisticLock.SetVersion(v)
	}

	return nil
}

func FromSoftDeleteComplete(data model.SoftDeleteComplete) SoftDeleteComplete {
	return SoftDeleteComplete{SoftDeleteComplete: data}
}
func FromSoftDeleteCompletePtr(data *model.SoftDeleteComplete) *SoftDeleteComplete {
	if data == nil {
		return nil
	}
	return &SoftDeleteComplete{SoftDeleteComplete: *data}
}

func ToSoftDeleteComplete(data SoftDeleteComplete) model.SoftDeleteComplete {
	return data.SoftDeleteComplete
}
func ToSoftDeleteCompletePtr(data *SoftDeleteComplete) *model.SoftDeleteComplete {
	if data == nil {
		return nil
	}
	result := data.SoftDeleteComplete
	return &result
}

type softDeleteCompleteLink struct {
	SoftDeleteComplete
	ID *som.ID
}

func (f *softDeleteCompleteLink) MarshalCBOR() ([]byte, error) {
	if f == nil {
		return nil, nil
	}
	return cbor.Marshal(f.ID)
}

func (f *softDeleteCompleteLink) UnmarshalCBOR(data []byte) error {
	if err := cbor.Unmarshal(data, &f.ID); err == nil {
		return nil
	}
	type alias softDeleteCompleteLink
	var link alias
	err := cbor.Unmarshal(data, &link)
	if err == nil {
		*f = softDeleteCompleteLink(link)
	}
	return err
}

func fromSoftDeleteCompleteLink(link *softDeleteCompleteLink) model.SoftDeleteComplete {
	if link == nil {
		return model.SoftDeleteComplete{}
	}
	res := SoftDeleteComplete(link.SoftDeleteComplete)
	return ToSoftDeleteComplete(res)
}

func fromSoftDeleteCompleteLinkPtr(link *softDeleteCompleteLink) *model.SoftDeleteComplete {
	if link == nil {
		return nil
	}
	res := SoftDeleteComplete(link.SoftDeleteComplete)
	out := ToSoftDeleteComplete(res)
	return &out
}

func toSoftDeleteCompleteLink(node model.SoftDeleteComplete) *softDeleteCompleteLink {
	if node.ID() == nil {
		return nil
	}
	link := softDeleteCompleteLink{SoftDeleteComplete: FromSoftDeleteComplete(node), ID: node.ID()}
	return &link
}

func toSoftDeleteCompleteLinkPtr(node *model.SoftDeleteComplete) *softDeleteCompleteLink {
	if node == nil || node.ID() == nil {
		return nil
	}
	link := softDeleteCompleteLink{SoftDeleteComplete: FromSoftDeleteComplete(*node), ID: node.ID()}
	return &link
}
