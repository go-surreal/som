// Code generated by github.com/go-surreal/som, DO NOT EDIT.
package where

import (
	som "github.com/go-surreal/som/tests/basic/gen/som"
	lib "github.com/go-surreal/som/tests/basic/gen/som/internal/lib"
	model "github.com/go-surreal/som/tests/basic/model"
	uuid "github.com/google/uuid"
	"net/url"
	"time"
)

var AllFieldTypes = newAllFieldTypes[model.AllFieldTypes](lib.NewKey[model.AllFieldTypes]())

func newAllFieldTypes[M any](key lib.Key[M]) allFieldTypes[M] {
	return allFieldTypes[M]{
		Bool:               lib.NewBool[M](lib.Field(key, "bool")),
		BoolPtr:            lib.NewBoolPtr[M](lib.Field(key, "bool_ptr")),
		BoolSlice:          lib.NewSliceMaker[M, bool, *lib.Bool[M]](lib.NewBool[M])(lib.Field(key, "bool_slice")),
		Byte:               lib.NewByte[M](lib.Field(key, "byte")),
		BytePtr:            lib.NewBytePtr[M](lib.Field(key, "byte_ptr")),
		ByteSlice:          lib.NewByteSlice[M](lib.Field(key, "byte_slice")),
		ByteSlicePtr:       lib.NewByteSlice[M](lib.Field(key, "byte_slice_ptr")),
		CreatedAt:          lib.NewTime[M](lib.Field(key, "created_at")),
		Duration:           lib.NewDuration[M](lib.Field(key, "duration")),
		DurationNil:        lib.NewDurationPtr[M](lib.Field(key, "duration_nil")),
		DurationPtr:        lib.NewDurationPtr[M](lib.Field(key, "duration_ptr")),
		DurationSlice:      lib.NewSliceMaker[M, time.Duration, *lib.Duration[M]](lib.NewDuration[M])(lib.Field(key, "duration_slice")),
		Email:              lib.NewEmail[M](lib.Field(key, "email")),
		EmailNil:           lib.NewEmailPtr[M](lib.Field(key, "email_nil")),
		EmailPtr:           lib.NewEmailPtr[M](lib.Field(key, "email_ptr")),
		EmailSlice:         lib.NewSliceMaker[M, som.Email, *lib.Email[M]](lib.NewEmail[M])(lib.Field(key, "email_slice")),
		EnumPtr:            lib.NewEnumPtr[M, model.Role](lib.Field(key, "enum_ptr")),
		EnumPtrSlice:       lib.NewSlice[M, model.Role](lib.Field(key, "enum_ptr_slice"), lib.NewEnumPtr[M, model.Role]),
		EnumPtrSlicePtr:    lib.NewSlicePtr[M, model.Role](lib.Field(key, "enum_ptr_slice_ptr"), lib.NewEnumPtr[M, model.Role]),
		Float32:            lib.NewFloat[M, float32](lib.Field(key, "float_32")),
		Float32PtrSlice:    lib.NewFloatPtrSlice[M, *float32](lib.Field(key, "float_32_ptr_slice")),
		Float32PtrSlicePtr: lib.NewFloatPtrSlicePtr[M, *float32](lib.Field(key, "float_32_ptr_slice_ptr")),
		Float32Slice:       lib.NewFloatSlice[M, float32](lib.Field(key, "float_32_slice")),
		Float32SlicePtr:    lib.NewFloatSlicePtr[M, float32](lib.Field(key, "float_32_slice_ptr")),
		Float64:            lib.NewFloat[M, float64](lib.Field(key, "float_64")),
		GroupsSlice:        lib.NewSliceMaker[M, []model.Group, *lib.Slice[M, model.Group, group[M]]](lib.NewSliceMaker[M, model.Group, group[M]](newGroup[M]))(lib.Field(key, "groups_slice")),
		ID:                 lib.NewID[M](lib.Field(key, "id"), "all_field_types"),
		Int:                lib.NewInt[M, int](lib.Field(key, "int")),
		Int16:              lib.NewInt[M, int16](lib.Field(key, "int_16")),
		Int16Ptr:           lib.NewIntPtr[M, *int16](lib.Field(key, "int_16_ptr")),
		Int32:              lib.NewInt[M, int32](lib.Field(key, "int_32")),
		Int32Ptr:           lib.NewIntPtr[M, *int32](lib.Field(key, "int_32_ptr")),
		Int64:              lib.NewInt[M, int64](lib.Field(key, "int_64")),
		Int64Ptr:           lib.NewIntPtr[M, *int64](lib.Field(key, "int_64_ptr")),
		Int8:               lib.NewInt[M, int8](lib.Field(key, "int_8")),
		Int8Ptr:            lib.NewIntPtr[M, *int8](lib.Field(key, "int_8_ptr")),
		IntPtr:             lib.NewIntPtr[M, *int](lib.Field(key, "int_ptr")),
		IntPtrSlice:        lib.NewIntPtrSlice[M, *int](lib.Field(key, "int_ptr_slice")),
		IntPtrSlicePtr:     lib.NewIntPtrSlicePtr[M, *int](lib.Field(key, "int_ptr_slice_ptr")),
		IntSlice:           lib.NewIntSlice[M, int](lib.Field(key, "int_slice")),
		IntSlicePtr:        lib.NewIntSlicePtr[M, int](lib.Field(key, "int_slice_ptr")),
		Key:                key,
		Other:              lib.NewStringSlice[M](lib.Field(key, "other")),
		Role:               lib.NewEnum[M, model.Role](lib.Field(key, "role")),
		Roles:              lib.NewSlice[M, model.Role](lib.Field(key, "roles"), lib.NewEnum[M, model.Role]),
		Rune:               lib.NewInt[M, rune](lib.Field(key, "rune")),
		RuneSlice:          lib.NewIntSlice[M, rune](lib.Field(key, "rune_slice")),
		SliceSlice:         lib.NewSliceMaker[M, []string, *lib.StringSlice[M]](lib.NewStringSlice[M])(lib.Field(key, "slice_slice")),
		SliceSliceSlice:    lib.NewSliceMaker[M, [][]string, *lib.Slice[M, []string, *lib.StringSlice[M]]](lib.NewSliceMaker[M, []string, *lib.StringSlice[M]](lib.NewStringSlice[M]))(lib.Field(key, "slice_slice_slice")),
		SliceSliceSlice2:   lib.NewSliceMaker[M, [][]model.SomeStruct, *lib.Slice[M, []model.SomeStruct, *lib.Slice[M, model.SomeStruct, someStruct[M]]]](lib.NewSliceMaker[M, []model.SomeStruct, *lib.Slice[M, model.SomeStruct, someStruct[M]]](lib.NewSliceMaker[M, model.SomeStruct, someStruct[M]](newSomeStruct[M])))(lib.Field(key, "slice_slice_slice_2")),
		String:             allFieldTypesString[M]{lib.NewString[M](lib.Field(key, "string"))},
		StringPtr:          lib.NewStringPtr[M](lib.Field(key, "string_ptr")),
		StringPtrSlice:     lib.NewStringPtrSlice[M](lib.Field(key, "string_ptr_slice")),
		StringSlicePtr:     lib.NewStringSlicePtr[M](lib.Field(key, "string_slice_ptr")),
		StructPtrSlice:     lib.NewSliceMaker[M, *model.SomeStruct, someStruct[M]](newSomeStruct[M])(lib.Field(key, "struct_ptr_slice")),
		StructPtrSlicePtr:  lib.NewSliceMakerPtr[M, *model.SomeStruct, someStruct[M]](newSomeStruct[M])(lib.Field(key, "struct_ptr_slice_ptr")),
		StructSlice:        lib.NewSliceMaker[M, model.SomeStruct, someStruct[M]](newSomeStruct[M])(lib.Field(key, "struct_slice")),
		Time:               lib.NewTime[M](lib.Field(key, "time")),
		TimeNil:            lib.NewTimePtr[M](lib.Field(key, "time_nil")),
		TimePtr:            lib.NewTimePtr[M](lib.Field(key, "time_ptr")),
		TimeSlice:          lib.NewSliceMaker[M, time.Time, *lib.Time[M]](lib.NewTime[M])(lib.Field(key, "time_slice")),
		TimeSliceSlice:     lib.NewSliceMaker[M, []time.Time, *lib.Slice[M, time.Time, *lib.Time[M]]](lib.NewSliceMaker[M, time.Time, *lib.Time[M]](lib.NewTime[M]))(lib.Field(key, "time_slice_slice")),
		URL:                lib.NewURL[M](lib.Field(key, "url")),
		URLNil:             lib.NewURLPtr[M](lib.Field(key, "url_nil")),
		URLPtr:             lib.NewURLPtr[M](lib.Field(key, "url_ptr")),
		URLSlice:           lib.NewSliceMaker[M, url.URL, *lib.URL[M]](lib.NewURL[M])(lib.Field(key, "url_slice")),
		UUID:               lib.NewUUID[M](lib.Field(key, "uuid")),
		UUIDNil:            lib.NewUUIDPtr[M](lib.Field(key, "uuid_nil")),
		UUIDPtr:            lib.NewUUIDPtr[M](lib.Field(key, "uuid_ptr")),
		UUIDSlice:          lib.NewSliceMaker[M, uuid.UUID, *lib.UUID[M]](lib.NewUUID[M])(lib.Field(key, "uuid_slice")),
		Uint16:             lib.NewInt[M, uint16](lib.Field(key, "uint_16")),
		Uint16Ptr:          lib.NewIntPtr[M, *uint16](lib.Field(key, "uint_16_ptr")),
		Uint32:             lib.NewInt[M, uint32](lib.Field(key, "uint_32")),
		Uint32Ptr:          lib.NewIntPtr[M, *uint32](lib.Field(key, "uint_32_ptr")),
		Uint8:              lib.NewInt[M, uint8](lib.Field(key, "uint_8")),
		Uint8Ptr:           lib.NewIntPtr[M, *uint8](lib.Field(key, "uint_8_ptr")),
		UpdatedAt:          lib.NewTime[M](lib.Field(key, "updated_at")),
	}
}

type allFieldTypes[M any] struct {
	lib.Key[M]
	ID                 *lib.ID[M]
	CreatedAt          *lib.Time[M]
	UpdatedAt          *lib.Time[M]
	String             allFieldTypesString[M]
	StringPtr          *lib.StringPtr[M]
	Other              *lib.StringSlice[M]
	StringPtrSlice     *lib.StringPtrSlice[M]
	StringSlicePtr     *lib.StringSlicePtr[M]
	Int                *lib.Int[M, int]
	IntPtr             *lib.IntPtr[M, *int]
	IntSlice           *lib.IntSlice[M, int]
	IntPtrSlice        *lib.IntPtrSlice[M, *int]
	IntSlicePtr        *lib.IntSlicePtr[M, int]
	IntPtrSlicePtr     *lib.IntPtrSlicePtr[M, *int]
	Int8               *lib.Int[M, int8]
	Int8Ptr            *lib.IntPtr[M, *int8]
	Int16              *lib.Int[M, int16]
	Int16Ptr           *lib.IntPtr[M, *int16]
	Int32              *lib.Int[M, int32]
	Int32Ptr           *lib.IntPtr[M, *int32]
	Int64              *lib.Int[M, int64]
	Int64Ptr           *lib.IntPtr[M, *int64]
	Uint8              *lib.Int[M, uint8]
	Uint8Ptr           *lib.IntPtr[M, *uint8]
	Uint16             *lib.Int[M, uint16]
	Uint16Ptr          *lib.IntPtr[M, *uint16]
	Uint32             *lib.Int[M, uint32]
	Uint32Ptr          *lib.IntPtr[M, *uint32]
	Float32            *lib.Float[M, float32]
	Float32Slice       *lib.FloatSlice[M, float32]
	Float32SlicePtr    *lib.FloatSlicePtr[M, float32]
	Float32PtrSlice    *lib.FloatPtrSlice[M, *float32]
	Float32PtrSlicePtr *lib.FloatPtrSlicePtr[M, *float32]
	Float64            *lib.Float[M, float64]
	Rune               *lib.Int[M, rune]
	RuneSlice          *lib.IntSlice[M, rune]
	Bool               *lib.Bool[M]
	BoolPtr            *lib.BoolPtr[M]
	BoolSlice          *lib.Slice[M, bool, *lib.Bool[M]]
	Time               *lib.Time[M]
	TimePtr            *lib.TimePtr[M]
	TimeNil            *lib.TimePtr[M]
	TimeSlice          *lib.Slice[M, time.Time, *lib.Time[M]]
	TimeSliceSlice     *lib.Slice[M, []time.Time, *lib.Slice[M, time.Time, *lib.Time[M]]]
	Duration           *lib.Duration[M]
	DurationPtr        *lib.DurationPtr[M]
	DurationNil        *lib.DurationPtr[M]
	DurationSlice      *lib.Slice[M, time.Duration, *lib.Duration[M]]
	UUID               *lib.UUID[M]
	UUIDPtr            *lib.UUIDPtr[M]
	UUIDNil            *lib.UUIDPtr[M]
	UUIDSlice          *lib.Slice[M, uuid.UUID, *lib.UUID[M]]
	URL                *lib.URL[M]
	URLPtr             *lib.URLPtr[M]
	URLNil             *lib.URLPtr[M]
	URLSlice           *lib.Slice[M, url.URL, *lib.URL[M]]
	Email              *lib.Email[M]
	EmailPtr           *lib.EmailPtr[M]
	EmailNil           *lib.EmailPtr[M]
	EmailSlice         *lib.Slice[M, som.Email, *lib.Email[M]]
	Role               *lib.Enum[M, model.Role]
	EnumPtr            *lib.EnumPtr[M, model.Role]
	Roles              *lib.Slice[M, model.Role, *lib.Enum[M, model.Role]]
	EnumPtrSlice       *lib.Slice[M, model.Role, *lib.EnumPtr[M, model.Role]]
	EnumPtrSlicePtr    *lib.SlicePtr[M, model.Role, *lib.EnumPtr[M, model.Role]]
	StructSlice        *lib.Slice[M, model.SomeStruct, someStruct[M]]
	StructPtrSlice     *lib.Slice[M, *model.SomeStruct, someStruct[M]]
	StructPtrSlicePtr  *lib.SlicePtr[M, *model.SomeStruct, someStruct[M]]
	GroupsSlice        *lib.Slice[M, []model.Group, *lib.Slice[M, model.Group, group[M]]]
	SliceSlice         *lib.Slice[M, []string, *lib.StringSlice[M]]
	SliceSliceSlice    *lib.Slice[M, [][]string, *lib.Slice[M, []string, *lib.StringSlice[M]]]
	SliceSliceSlice2   *lib.Slice[M, [][]model.SomeStruct, *lib.Slice[M, []model.SomeStruct, *lib.Slice[M, model.SomeStruct, someStruct[M]]]]
	Byte               *lib.Byte[M]
	BytePtr            *lib.BytePtr[M]
	ByteSlice          *lib.ByteSlice[M]
	ByteSlicePtr       *lib.ByteSlice[M]
}

func (n allFieldTypes[M]) Login() login[M] {
	return newLogin[M](lib.Field(n.Key, "login"))
}

func (n allFieldTypes[M]) StructPtr() someStruct[M] {
	return newSomeStruct[M](lib.Field(n.Key, "struct_ptr"))
}

func (n allFieldTypes[M]) MainGroup() group[M] {
	return newGroup[M](lib.Field(n.Key, "main_group"))
}

func (n allFieldTypes[M]) MainGroupPtr() group[M] {
	return newGroup[M](lib.Field(n.Key, "main_group_ptr"))
}

func (n allFieldTypes[M]) Groups(filters ...lib.Filter[model.Group]) *lib.Slice[M, model.Group, group[M]] {
	key := lib.Node(n.Key, "groups", filters)
	return lib.NewSlice[M, model.Group, group[M]](key, newGroup[M])
}

func (n allFieldTypes[M]) NodePtrSlice(filters ...lib.Filter[model.Group]) *lib.Slice[M, model.Group, group[M]] {
	key := lib.Node(n.Key, "node_ptr_slice", filters)
	return lib.NewSlice[M, model.Group, group[M]](key, newGroup[M])
}

func (n allFieldTypes[M]) NodePtrSlicePtr(filters ...lib.Filter[model.Group]) *lib.Slice[M, model.Group, group[M]] {
	key := lib.Node(n.Key, "node_ptr_slice_ptr", filters)
	return lib.NewSlice[M, model.Group, group[M]](key, newGroup[M])
}

func (n allFieldTypes[M]) MemberOf(filters ...lib.Filter[model.GroupMember]) groupMemberIn[M] {
	return newGroupMemberIn[M](lib.EdgeIn(n.Key, "group_member", filters))
}

type allFieldTypesString[M any] struct {
	*lib.String[M]
}

func (f allFieldTypesString[M]) Matches(terms string) lib.Search[M] {
	return lib.NewSearch[M](f.String.Base.Key, terms)
}
func (f allFieldTypesString[M]) key() lib.Key[M] {
	return f.String.Base.Key
}

type allFieldTypesEdges[M any] struct {
	lib.Filter[M]
	lib.Key[M]
}

func (n allFieldTypesEdges[M]) MemberOf(filters ...lib.Filter[model.GroupMember]) groupMemberIn[M] {
	return newGroupMemberIn[M](lib.EdgeIn(n.Key, "group_member", filters))
}
