// Code generated by github.com/go-surreal/som, DO NOT EDIT.
package filter

import (
	som "github.com/go-surreal/som/tests/basic/gen/som"
	lib "github.com/go-surreal/som/tests/basic/gen/som/internal/lib"
	model "github.com/go-surreal/som/tests/basic/model"
	uuid "github.com/gofrs/uuid"
	uuid1 "github.com/google/uuid"
	"net/url"
	"time"
)

var AllTypes = newAllTypes[model.AllTypes](lib.NewKey[model.AllTypes]())

func newAllTypes[M any](key lib.Key[M]) allTypes[M] {
	return allTypes[M]{
		CreatedAt:               lib.NewTime[M](lib.Field(key, "created_at")),
		FieldBool:               lib.NewBool[M](lib.Field(key, "field_bool")),
		FieldBoolPtr:            lib.NewBoolPtr[M](lib.Field(key, "field_bool_ptr")),
		FieldBoolSlice:          lib.NewSliceMaker[M, bool, *lib.Bool[M]](lib.NewBool[M])(lib.Field(key, "field_bool_slice")),
		FieldByte:               lib.NewByte[M](lib.Field(key, "field_byte")),
		FieldBytePtr:            lib.NewBytePtr[M](lib.Field(key, "field_byte_ptr")),
		FieldByteSlice:          lib.NewByteSlice[M](lib.Field(key, "field_byte_slice")),
		FieldByteSlicePtr:       lib.NewByteSlice[M](lib.Field(key, "field_byte_slice_ptr")),
		FieldDuration:           lib.NewDuration[M](lib.Field(key, "field_duration")),
		FieldDurationNil:        lib.NewDurationPtr[M](lib.Field(key, "field_duration_nil")),
		FieldDurationPtr:        lib.NewDurationPtr[M](lib.Field(key, "field_duration_ptr")),
		FieldDurationSlice:      lib.NewSliceMaker[M, time.Duration, *lib.Duration[M]](lib.NewDuration[M])(lib.Field(key, "field_duration_slice")),
		FieldEmail:              lib.NewEmail[M](lib.Field(key, "field_email")),
		FieldEmailNil:           lib.NewEmailPtr[M](lib.Field(key, "field_email_nil")),
		FieldEmailPtr:           lib.NewEmailPtr[M](lib.Field(key, "field_email_ptr")),
		FieldEmailSlice:         lib.NewSliceMaker[M, som.Email, *lib.Email[M]](lib.NewEmail[M])(lib.Field(key, "field_email_slice")),
		FieldEnum:               lib.NewEnum[M, model.Role](lib.Field(key, "field_enum")),
		FieldEnumPtr:            lib.NewEnumPtr[M, model.Role](lib.Field(key, "field_enum_ptr")),
		FieldEnumPtrSlice:       lib.NewSlice[M, model.Role](lib.Field(key, "field_enum_ptr_slice"), lib.NewEnumPtr[M, model.Role]),
		FieldEnumPtrSlicePtr:    lib.NewSlicePtr[M, model.Role](lib.Field(key, "field_enum_ptr_slice_ptr"), lib.NewEnumPtr[M, model.Role]),
		FieldEnumSlice:          lib.NewSlice[M, model.Role](lib.Field(key, "field_enum_slice"), lib.NewEnum[M, model.Role]),
		FieldFloat32:            lib.NewFloat[M, float32](lib.Field(key, "field_float_32")),
		FieldFloat32PtrSlice:    lib.NewFloatPtrSlice[M, *float32](lib.Field(key, "field_float_32_ptr_slice")),
		FieldFloat32PtrSlicePtr: lib.NewFloatPtrSlicePtr[M, *float32](lib.Field(key, "field_float_32_ptr_slice_ptr")),
		FieldFloat32Slice:       lib.NewFloatSlice[M, float32](lib.Field(key, "field_float_32_slice")),
		FieldFloat32SlicePtr:    lib.NewFloatSlicePtr[M, float32](lib.Field(key, "field_float_32_slice_ptr")),
		FieldFloat64:            lib.NewFloat[M, float64](lib.Field(key, "field_float_64")),
		FieldHookDetail:         lib.NewString[M](lib.Field(key, "field_hook_detail")),
		FieldHookStatus:         lib.NewString[M](lib.Field(key, "field_hook_status")),
		FieldInt:                lib.NewInt[M, int](lib.Field(key, "field_int")),
		FieldInt16:              lib.NewInt[M, int16](lib.Field(key, "field_int_16")),
		FieldInt16Ptr:           lib.NewIntPtr[M, *int16](lib.Field(key, "field_int_16_ptr")),
		FieldInt32:              lib.NewInt[M, int32](lib.Field(key, "field_int_32")),
		FieldInt32Ptr:           lib.NewIntPtr[M, *int32](lib.Field(key, "field_int_32_ptr")),
		FieldInt64:              lib.NewInt[M, int64](lib.Field(key, "field_int_64")),
		FieldInt64Ptr:           lib.NewIntPtr[M, *int64](lib.Field(key, "field_int_64_ptr")),
		FieldInt8:               lib.NewInt[M, int8](lib.Field(key, "field_int_8")),
		FieldInt8Ptr:            lib.NewIntPtr[M, *int8](lib.Field(key, "field_int_8_ptr")),
		FieldIntPtr:             lib.NewIntPtr[M, *int](lib.Field(key, "field_int_ptr")),
		FieldIntPtrSlice:        lib.NewIntPtrSlice[M, *int](lib.Field(key, "field_int_ptr_slice")),
		FieldIntPtrSlicePtr:     lib.NewIntPtrSlicePtr[M, *int](lib.Field(key, "field_int_ptr_slice_ptr")),
		FieldIntSlice:           lib.NewIntSlice[M, int](lib.Field(key, "field_int_slice")),
		FieldIntSlicePtr:        lib.NewIntSlicePtr[M, int](lib.Field(key, "field_int_slice_ptr")),
		FieldMonth:              lib.NewMonth[M](lib.Field(key, "field_month")),
		FieldMonthPtr:           lib.NewMonthPtr[M](lib.Field(key, "field_month_ptr")),
		FieldNodeSliceSlice:     lib.NewSliceMaker[M, []model.SpecialTypes, *lib.Slice[M, model.SpecialTypes, specialTypes[M]]](lib.NewSliceMaker[M, model.SpecialTypes, specialTypes[M]](newSpecialTypes[M]))(lib.Field(key, "field_node_slice_slice")),
		FieldOther:              allTypesFieldOther[M]{lib.NewStringSlice[M](lib.Field(key, "field_other"))},
		FieldRenamed:            lib.NewString[M](lib.Field(key, "custom_name")),
		FieldRune:               lib.NewInt[M, rune](lib.Field(key, "field_rune")),
		FieldRuneSlice:          lib.NewIntSlice[M, rune](lib.Field(key, "field_rune_slice")),
		FieldSliceSlice:         lib.NewSliceMaker[M, []string, *lib.StringSlice[M]](lib.NewStringSlice[M])(lib.Field(key, "field_slice_slice")),
		FieldSliceSliceSlice:    lib.NewSliceMaker[M, [][]string, *lib.Slice[M, []string, *lib.StringSlice[M]]](lib.NewSliceMaker[M, []string, *lib.StringSlice[M]](lib.NewStringSlice[M]))(lib.Field(key, "field_slice_slice_slice")),
		FieldSliceSliceSlice2:   lib.NewSliceMaker[M, [][]model.NestedData, *lib.Slice[M, []model.NestedData, *lib.Slice[M, model.NestedData, nestedData[M]]]](lib.NewSliceMaker[M, []model.NestedData, *lib.Slice[M, model.NestedData, nestedData[M]]](lib.NewSliceMaker[M, model.NestedData, nestedData[M]](newNestedData[M])))(lib.Field(key, "field_slice_slice_slice_2")),
		FieldString:             allTypesFieldString[M]{lib.NewString[M](lib.Field(key, "field_string"))},
		FieldStringPtr:          allTypesFieldStringPtr[M]{lib.NewStringPtr[M](lib.Field(key, "field_string_ptr"))},
		FieldStringPtrSlice:     allTypesFieldStringPtrSlice[M]{lib.NewStringPtrSlice[M](lib.Field(key, "field_string_ptr_slice"))},
		FieldStringPtrSlicePtr:  allTypesFieldStringPtrSlicePtr[M]{lib.NewStringPtrSlicePtr[M](lib.Field(key, "field_string_ptr_slice_ptr"))},
		FieldStringSlicePtr:     allTypesFieldStringSlicePtr[M]{lib.NewStringSlicePtr[M](lib.Field(key, "field_string_slice_ptr"))},
		FieldTime:               lib.NewTime[M](lib.Field(key, "field_time")),
		FieldTimeNil:            lib.NewTimePtr[M](lib.Field(key, "field_time_nil")),
		FieldTimePtr:            lib.NewTimePtr[M](lib.Field(key, "field_time_ptr")),
		FieldTimeSlice:          lib.NewSliceMaker[M, time.Time, *lib.Time[M]](lib.NewTime[M])(lib.Field(key, "field_time_slice")),
		FieldTimeSliceSlice:     lib.NewSliceMaker[M, []time.Time, *lib.Slice[M, time.Time, *lib.Time[M]]](lib.NewSliceMaker[M, time.Time, *lib.Time[M]](lib.NewTime[M]))(lib.Field(key, "field_time_slice_slice")),
		FieldURL:                lib.NewURL[M](lib.Field(key, "field_url")),
		FieldURLNil:             lib.NewURLPtr[M](lib.Field(key, "field_url_nil")),
		FieldURLPtr:             lib.NewURLPtr[M](lib.Field(key, "field_url_ptr")),
		FieldURLSlice:           lib.NewSliceMaker[M, url.URL, *lib.URL[M]](lib.NewURL[M])(lib.Field(key, "field_url_slice")),
		FieldUUID:               lib.NewUUIDGoogle[M](lib.Field(key, "field_uuid")),
		FieldUUIDGofrs:          lib.NewUUIDGofrs[M](lib.Field(key, "field_uuid_gofrs")),
		FieldUUIDGofrsNil:       lib.NewUUIDGofrsPtr[M](lib.Field(key, "field_uuid_gofrs_nil")),
		FieldUUIDGofrsPtr:       lib.NewUUIDGofrsPtr[M](lib.Field(key, "field_uuid_gofrs_ptr")),
		FieldUUIDGofrsSlice:     lib.NewSliceMaker[M, uuid.UUID, *lib.UUIDGofrs[M]](lib.NewUUIDGofrs[M])(lib.Field(key, "field_uuid_gofrs_slice")),
		FieldUUIDNil:            lib.NewUUIDGooglePtr[M](lib.Field(key, "field_uuid_nil")),
		FieldUUIDPtr:            lib.NewUUIDGooglePtr[M](lib.Field(key, "field_uuid_ptr")),
		FieldUUIDSlice:          lib.NewSliceMaker[M, uuid1.UUID, *lib.UUIDGoogle[M]](lib.NewUUIDGoogle[M])(lib.Field(key, "field_uuid_slice")),
		FieldUint16:             lib.NewInt[M, uint16](lib.Field(key, "field_uint_16")),
		FieldUint16Ptr:          lib.NewIntPtr[M, *uint16](lib.Field(key, "field_uint_16_ptr")),
		FieldUint32:             lib.NewInt[M, uint32](lib.Field(key, "field_uint_32")),
		FieldUint32Ptr:          lib.NewIntPtr[M, *uint32](lib.Field(key, "field_uint_32_ptr")),
		FieldUint8:              lib.NewInt[M, uint8](lib.Field(key, "field_uint_8")),
		FieldUint8Ptr:           lib.NewIntPtr[M, *uint8](lib.Field(key, "field_uint_8_ptr")),
		FieldWeekday:            lib.NewWeekday[M](lib.Field(key, "field_weekday")),
		FieldWeekdayPtr:         lib.NewWeekdayPtr[M](lib.Field(key, "field_weekday_ptr")),
		ID:                      lib.NewID[M](lib.Field(key, "id"), "all_types"),
		Key:                     key,
		UpdatedAt:               lib.NewTime[M](lib.Field(key, "updated_at")),
	}
}

type allTypes[M any] struct {
	lib.Key[M]
	ID                      *lib.ID[M]
	CreatedAt               *lib.Time[M]
	UpdatedAt               *lib.Time[M]
	FieldString             allTypesFieldString[M]
	FieldStringPtr          allTypesFieldStringPtr[M]
	FieldOther              allTypesFieldOther[M]
	FieldStringPtrSlice     allTypesFieldStringPtrSlice[M]
	FieldStringSlicePtr     allTypesFieldStringSlicePtr[M]
	FieldStringPtrSlicePtr  allTypesFieldStringPtrSlicePtr[M]
	FieldInt                *lib.Int[M, int]
	FieldIntPtr             *lib.IntPtr[M, *int]
	FieldIntSlice           *lib.IntSlice[M, int]
	FieldIntPtrSlice        *lib.IntPtrSlice[M, *int]
	FieldIntSlicePtr        *lib.IntSlicePtr[M, int]
	FieldIntPtrSlicePtr     *lib.IntPtrSlicePtr[M, *int]
	FieldInt8               *lib.Int[M, int8]
	FieldInt8Ptr            *lib.IntPtr[M, *int8]
	FieldInt16              *lib.Int[M, int16]
	FieldInt16Ptr           *lib.IntPtr[M, *int16]
	FieldInt32              *lib.Int[M, int32]
	FieldInt32Ptr           *lib.IntPtr[M, *int32]
	FieldInt64              *lib.Int[M, int64]
	FieldInt64Ptr           *lib.IntPtr[M, *int64]
	FieldUint8              *lib.Int[M, uint8]
	FieldUint8Ptr           *lib.IntPtr[M, *uint8]
	FieldUint16             *lib.Int[M, uint16]
	FieldUint16Ptr          *lib.IntPtr[M, *uint16]
	FieldUint32             *lib.Int[M, uint32]
	FieldUint32Ptr          *lib.IntPtr[M, *uint32]
	FieldFloat32            *lib.Float[M, float32]
	FieldFloat32Slice       *lib.FloatSlice[M, float32]
	FieldFloat32SlicePtr    *lib.FloatSlicePtr[M, float32]
	FieldFloat32PtrSlice    *lib.FloatPtrSlice[M, *float32]
	FieldFloat32PtrSlicePtr *lib.FloatPtrSlicePtr[M, *float32]
	FieldFloat64            *lib.Float[M, float64]
	FieldRune               *lib.Int[M, rune]
	FieldRuneSlice          *lib.IntSlice[M, rune]
	FieldBool               *lib.Bool[M]
	FieldBoolPtr            *lib.BoolPtr[M]
	FieldBoolSlice          *lib.Slice[M, bool, *lib.Bool[M]]
	FieldTime               *lib.Time[M]
	FieldTimePtr            *lib.TimePtr[M]
	FieldTimeNil            *lib.TimePtr[M]
	FieldTimeSlice          *lib.Slice[M, time.Time, *lib.Time[M]]
	FieldTimeSliceSlice     *lib.Slice[M, []time.Time, *lib.Slice[M, time.Time, *lib.Time[M]]]
	FieldDuration           *lib.Duration[M]
	FieldDurationPtr        *lib.DurationPtr[M]
	FieldDurationNil        *lib.DurationPtr[M]
	FieldDurationSlice      *lib.Slice[M, time.Duration, *lib.Duration[M]]
	FieldMonth              *lib.Month[M]
	FieldMonthPtr           *lib.MonthPtr[M]
	FieldWeekday            *lib.Weekday[M]
	FieldWeekdayPtr         *lib.WeekdayPtr[M]
	FieldUUID               *lib.UUIDGoogle[M]
	FieldUUIDPtr            *lib.UUIDGooglePtr[M]
	FieldUUIDNil            *lib.UUIDGooglePtr[M]
	FieldUUIDSlice          *lib.Slice[M, uuid1.UUID, *lib.UUIDGoogle[M]]
	FieldUUIDGofrs          *lib.UUIDGofrs[M]
	FieldUUIDGofrsPtr       *lib.UUIDGofrsPtr[M]
	FieldUUIDGofrsNil       *lib.UUIDGofrsPtr[M]
	FieldUUIDGofrsSlice     *lib.Slice[M, uuid.UUID, *lib.UUIDGofrs[M]]
	FieldURL                *lib.URL[M]
	FieldURLPtr             *lib.URLPtr[M]
	FieldURLNil             *lib.URLPtr[M]
	FieldURLSlice           *lib.Slice[M, url.URL, *lib.URL[M]]
	FieldEmail              *lib.Email[M]
	FieldEmailPtr           *lib.EmailPtr[M]
	FieldEmailNil           *lib.EmailPtr[M]
	FieldEmailSlice         *lib.Slice[M, som.Email, *lib.Email[M]]
	FieldEnum               *lib.Enum[M, model.Role]
	FieldEnumPtr            *lib.EnumPtr[M, model.Role]
	FieldEnumSlice          *lib.Slice[M, model.Role, *lib.Enum[M, model.Role]]
	FieldEnumPtrSlice       *lib.Slice[M, model.Role, *lib.EnumPtr[M, model.Role]]
	FieldEnumPtrSlicePtr    *lib.SlicePtr[M, model.Role, *lib.EnumPtr[M, model.Role]]
	FieldNodeSliceSlice     *lib.Slice[M, []model.SpecialTypes, *lib.Slice[M, model.SpecialTypes, specialTypes[M]]]
	FieldSliceSlice         *lib.Slice[M, []string, *lib.StringSlice[M]]
	FieldSliceSliceSlice    *lib.Slice[M, [][]string, *lib.Slice[M, []string, *lib.StringSlice[M]]]
	FieldSliceSliceSlice2   *lib.Slice[M, [][]model.NestedData, *lib.Slice[M, []model.NestedData, *lib.Slice[M, model.NestedData, nestedData[M]]]]
	FieldByte               *lib.Byte[M]
	FieldBytePtr            *lib.BytePtr[M]
	FieldByteSlice          *lib.ByteSlice[M]
	FieldByteSlicePtr       *lib.ByteSlice[M]
	FieldRenamed            *lib.String[M]
	FieldHookStatus         *lib.String[M]
	FieldHookDetail         *lib.String[M]
}

func (n allTypes[M]) FieldCredentials() credentials[M] {
	return newCredentials[M](lib.Field(n.Key, "field_credentials"))
}

func (n allTypes[M]) FieldNestedDataPtr() nestedData[M] {
	return newNestedData[M](lib.Field(n.Key, "field_nested_data_ptr"))
}

func (n allTypes[M]) FieldNestedDataSlice(filters ...lib.Filter[model.NestedData]) *lib.Slice[M, model.NestedData, nestedData[M]] {
	key := lib.StructField(n.Key, "field_nested_data_slice", filters)
	return lib.NewSlice[M, model.NestedData, nestedData[M]](key, newNestedData[M])
}

func (n allTypes[M]) FieldNestedDataPtrSlice(filters ...lib.Filter[model.NestedData]) *lib.Slice[M, *model.NestedData, nestedData[M]] {
	key := lib.StructField(n.Key, "field_nested_data_ptr_slice", filters)
	return lib.NewSlice[M, *model.NestedData, nestedData[M]](key, newNestedData[M])
}

func (n allTypes[M]) FieldNestedDataPtrSlicePtr(filters ...lib.Filter[model.NestedData]) *lib.SlicePtr[M, *model.NestedData, nestedData[M]] {
	key := lib.StructField(n.Key, "field_nested_data_ptr_slice_ptr", filters)
	return lib.NewSlicePtr[M, *model.NestedData, nestedData[M]](key, newNestedData[M])
}

func (n allTypes[M]) FieldNode() specialTypes[M] {
	return newSpecialTypes[M](lib.Field(n.Key, "field_node"))
}

func (n allTypes[M]) FieldNodePtr() specialTypes[M] {
	return newSpecialTypes[M](lib.Field(n.Key, "field_node_ptr"))
}

func (n allTypes[M]) FieldNodeSlice(filters ...lib.Filter[model.SpecialTypes]) *lib.Slice[M, model.SpecialTypes, specialTypes[M]] {
	key := lib.Node(n.Key, "field_node_slice", filters)
	return lib.NewSlice[M, model.SpecialTypes, specialTypes[M]](key, newSpecialTypes[M])
}

func (n allTypes[M]) FieldNodePtrSlice(filters ...lib.Filter[model.SpecialTypes]) *lib.Slice[M, model.SpecialTypes, specialTypes[M]] {
	key := lib.Node(n.Key, "field_node_ptr_slice", filters)
	return lib.NewSlice[M, model.SpecialTypes, specialTypes[M]](key, newSpecialTypes[M])
}

func (n allTypes[M]) FieldNodePtrSlicePtr(filters ...lib.Filter[model.SpecialTypes]) *lib.Slice[M, model.SpecialTypes, specialTypes[M]] {
	key := lib.Node(n.Key, "field_node_ptr_slice_ptr", filters)
	return lib.NewSlice[M, model.SpecialTypes, specialTypes[M]](key, newSpecialTypes[M])
}

func (n allTypes[M]) FieldEdgeRelations(filters ...lib.Filter[model.EdgeRelation]) edgeRelationIn[M] {
	return newEdgeRelationIn[M](lib.EdgeIn(n.Key, "edge_relation", filters))
}

type allTypesFieldString[M any] struct {
	*lib.String[M]
}

func (f allTypesFieldString[M]) Matches(terms string) lib.Search[M] {
	return lib.NewSearch[M](f.String.Base.Key, terms)
}
func (f allTypesFieldString[M]) MatchesAny(terms string) lib.Search[M] {
	return lib.NewSearchOr[M](f.String.Base.Key, terms)
}
func (f allTypesFieldString[M]) key() lib.Key[M] {
	return f.String.Base.Key
}

type allTypesFieldStringPtr[M any] struct {
	*lib.StringPtr[M]
}

func (f allTypesFieldStringPtr[M]) Matches(terms string) lib.Search[M] {
	return lib.NewSearch[M](f.StringPtr.Base.Key, terms)
}
func (f allTypesFieldStringPtr[M]) MatchesAny(terms string) lib.Search[M] {
	return lib.NewSearchOr[M](f.StringPtr.Base.Key, terms)
}
func (f allTypesFieldStringPtr[M]) key() lib.Key[M] {
	return f.StringPtr.Base.Key
}

type allTypesFieldOther[M any] struct {
	*lib.StringSlice[M]
}

func (f allTypesFieldOther[M]) Matches(terms string) lib.Search[M] {
	return lib.NewSearch[M](f.StringSlice.Key, terms)
}
func (f allTypesFieldOther[M]) MatchesAny(terms string) lib.Search[M] {
	return lib.NewSearchOr[M](f.StringSlice.Key, terms)
}
func (f allTypesFieldOther[M]) key() lib.Key[M] {
	return f.StringSlice.Key
}

type allTypesFieldStringPtrSlice[M any] struct {
	*lib.StringPtrSlice[M]
}

func (f allTypesFieldStringPtrSlice[M]) Matches(terms string) lib.Search[M] {
	return lib.NewSearch[M](f.StringPtrSlice.Key, terms)
}
func (f allTypesFieldStringPtrSlice[M]) MatchesAny(terms string) lib.Search[M] {
	return lib.NewSearchOr[M](f.StringPtrSlice.Key, terms)
}
func (f allTypesFieldStringPtrSlice[M]) key() lib.Key[M] {
	return f.StringPtrSlice.Key
}

type allTypesFieldStringSlicePtr[M any] struct {
	*lib.StringSlicePtr[M]
}

func (f allTypesFieldStringSlicePtr[M]) Matches(terms string) lib.Search[M] {
	return lib.NewSearch[M](f.StringSlicePtr.Slice.Key, terms)
}
func (f allTypesFieldStringSlicePtr[M]) MatchesAny(terms string) lib.Search[M] {
	return lib.NewSearchOr[M](f.StringSlicePtr.Slice.Key, terms)
}
func (f allTypesFieldStringSlicePtr[M]) key() lib.Key[M] {
	return f.StringSlicePtr.Slice.Key
}

type allTypesFieldStringPtrSlicePtr[M any] struct {
	*lib.StringPtrSlicePtr[M]
}

func (f allTypesFieldStringPtrSlicePtr[M]) Matches(terms string) lib.Search[M] {
	return lib.NewSearch[M](f.StringPtrSlicePtr.Slice.Key, terms)
}
func (f allTypesFieldStringPtrSlicePtr[M]) MatchesAny(terms string) lib.Search[M] {
	return lib.NewSearchOr[M](f.StringPtrSlicePtr.Slice.Key, terms)
}
func (f allTypesFieldStringPtrSlicePtr[M]) key() lib.Key[M] {
	return f.StringPtrSlicePtr.Slice.Key
}

type allTypesEdges[M any] struct {
	lib.Filter[M]
	lib.Key[M]
}

func (n allTypesEdges[M]) FieldEdgeRelations(filters ...lib.Filter[model.EdgeRelation]) edgeRelationIn[M] {
	return newEdgeRelationIn[M](lib.EdgeIn(n.Key, "edge_relation", filters))
}
