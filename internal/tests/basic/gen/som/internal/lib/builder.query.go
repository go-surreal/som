// Code generated by github.com/go-surreal/som, DO NOT EDIT.

package lib

import (
	"strconv"
	"strings"
	"time"
)

const (
	somPrefix             = "__som__"
	sortFieldPrefix       = somPrefix + "sort_"
	searchScorePrefix     = somPrefix + "search_score_"
	searchHighlightPrefix = somPrefix + "search_highlight_"
	searchOffsetsPrefix   = somPrefix + "search_offsets_"
)

type context struct {
	varIndex int32
	vars     map[string]any
}

func (c *context) Vars() map[string]any {
	return c.vars
}

// TODO: deduplicate same values in the same query
func (c *context) asVar(val any) string {
	index := intToLetters(c.varIndex)
	c.varIndex++
	c.vars[index] = val
	return "$" + index
}

type Query[T any] struct {
	context
	node       string
	live       bool
	fields     []string
	groupBy    string
	groupAll   bool
	Where      []Filter[T]
	Sort       []*SortBuilder
	SortRandom bool
	Fetch      []string
	Offset     int
	Limit      int
	Timeout    time.Duration
	Parallel   bool

	SearchClauses []SearchClause
	SearchWhere   string
}

func NewQuery[T any](node string) Query[T] {
	return Query[T]{
		context: context{
			varIndex: 0,
			vars:     map[string]any{},
		},
		node: node,
	}
}

func (q Query[T]) BuildAsAll() *Result {
	q.fields = []string{"*"}

	return &Result{
		Statement: q.render(),
		Variables: q.context.vars,
	}
}

func (q Query[T]) BuildAsAllIDs() *Result {
	q.fields = []string{"id"}

	return &Result{
		Statement: q.render(),
		Variables: q.context.vars,
	}
}

func (q Query[T]) BuildAsCount() *Result {
	q.fields = []string{"count()"}
	q.groupAll = true

	return &Result{
		Statement: q.render(),
		Variables: q.context.vars,
	}
}

func (q Query[T]) BuildAsLive() *Result {
	q.live = true
	q.fields = []string{"*"}

	return &Result{
		Statement: q.render(),
		Variables: q.context.vars,
	}
}

func (q Query[T]) BuildAsLiveDiff() *Result {
	q.live = true
	q.fields = []string{"DIFF"}

	return &Result{
		Statement: q.render(),
		Variables: q.context.vars,
	}
}

func (q Query[T]) render() string {
	var out strings.Builder

	// TODO: possible optimization: preallocate buffer (e.g. out.Grow(<known bytes>))

	if q.live {
		out.WriteString("LIVE ")
	}

	fields := q.fields
	for _, s := range q.Sort {
		fields = append(fields, s.Field+" as "+sortFieldPrefix+s.Field)
	}

	// Add search score, highlight, and offset projections
	for _, sc := range q.SearchClauses {
		ref := strconv.Itoa(sc.Ref)
		fields = append(fields, "search::score("+ref+") AS "+searchScorePrefix+ref)
		if sc.Highlights {
			fields = append(fields,
				"search::highlight("+q.context.asVar(sc.HLPrefix)+", "+q.context.asVar(sc.HLSuffix)+", "+ref+") AS "+searchHighlightPrefix+ref)
		}
		if sc.Offsets {
			fields = append(fields, "search::offsets("+ref+") AS "+searchOffsetsPrefix+ref)
		}
	}

	// Add combined score projection if any score sort exists
	for _, s := range q.Sort {
		if s.IsScore && len(s.ScoreRefs) > 0 {
			expr := renderScoreCombination(s.ScoreRefs, s.ScoreMode, s.ScoreWeights)
			fields = append(fields, expr+" AS "+searchScorePrefix+"combined")
			break
		}
	}

	out.WriteString("SELECT " + strings.Join(fields, ", "))

	// TODO: not working, but more a optimisation than anything else
	//if len(q.Sort) > 0 {
	//	out.WriteString(" OMIT ")
	//	var omitFields []string
	//	for _, s := range q.Sort {
	//		omitFields = append(omitFields, "__som_"+s.Field)
	//	}
	//	out.WriteString(strings.Join(omitFields, ", "))
	//}

	out.WriteString(" FROM " + q.node)

	// Build WHERE clause combining search and regular filters
	var whereParts []string

	// Add search conditions first
	if q.SearchWhere != "" {
		whereParts = append(whereParts, q.SearchWhere)
	}

	// Add regular filters
	var t T
	filterWhere := All[T](q.Where).build(&q.context, t)
	if filterWhere != "" {
		whereParts = append(whereParts, filterWhere)
	}

	if len(whereParts) > 0 {
		out.WriteString(" WHERE ")
		out.WriteString(strings.Join(whereParts, " AND "))
	}

	if !q.live && q.groupBy != "" {
		out.WriteString(" GROUP BY ")
		out.WriteString(q.groupBy)
	}

	if !q.live && q.groupAll {
		out.WriteString(" GROUP ALL")
	}

	if !q.live && q.SortRandom {
		out.WriteString(" ORDER BY RAND()")
	} else if !q.live && len(q.Sort) > 0 {
		var sorts []string
		for _, s := range q.Sort {
			sorts = append(sorts, s.render())
		}
		out.WriteString(" ORDER BY ")
		out.WriteString(strings.Join(sorts, ", "))
	}

	// LIMIT must come before START.
	if !q.live && q.Limit > 0 {
		out.WriteString(" LIMIT ")
		out.WriteString(strconv.Itoa(q.Limit))
	}

	// START must come after LIMIT.
	if !q.live && q.Offset > 0 {
		out.WriteString(" START ")
		out.WriteString(strconv.Itoa(q.Offset))
	}

	if len(q.Fetch) > 0 {
		out.WriteString(" FETCH ")
		out.WriteString(strings.Join(q.Fetch, ", "))
	}

	if !q.live && q.Timeout > 0 {
		out.WriteString(" TIMEOUT ")
		out.WriteString(q.Timeout.Round(time.Second).String())
	}

	if !q.live && q.Parallel {
		out.WriteString(" PARALLEL")
	}

	return out.String()
}

type Result struct {
	Statement string
	Variables map[string]any
}

type Operator string

const (
	OpAnd Operator = "AND" // ("&&") Checks whether both of two values are truthy.
	OpOr  Operator = "OR"  // ("||") Checks whether either of two values is truthy.

	OpEqual         Operator = "="  // ("IS") Check whether two values are equal.
	OpNotEqual      Operator = "!=" // ("IS NOT") Check whether two values are not equal.
	OpExactlyEqual  Operator = "==" // Check whether two values are exactly equal.
	OpFuzzyMatch    Operator = "~"  // Compare two values for equality using fuzzy matching.
	OpFuzzyNotMatch Operator = "!~" // Compare two values for inequality using fuzzy matching.

	OpAnyEqual      Operator = "?=" // Check whether any value in a set is equal to a value.
	OpAllEqual      Operator = "*=" // Check whether all values in a set are equal to a value.
	OpAnyFuzzyMatch Operator = "?~" // Check whether any value in a set is equal to a value using fuzzy matching.
	OpAllFuzzyMatch Operator = "*~" // Check whether all values in a set are equal to a value using fuzzy matching.

	OpLessThan         Operator = "<"  // Check whether a value is less than another value.
	OpLessThanEqual    Operator = "<=" // Check whether a value is less than or equal to another value.
	OpGreaterThan      Operator = ">"  // Check whether a value is greater than another value.
	OpGreaterThanEqual Operator = ">=" // Check whether a value is greater than or equal to another value.

	OpAdd   Operator = "+"  // 	Add two values together.
	OpSub   Operator = "-"  // Subtract a value from another value.
	OpMul   Operator = "×"  // ("*") Multiply two values together.
	OpDiv   Operator = "÷"  // ("/") Divide a value by another value.
	OpRaise Operator = "**" // Raises a base value by another value.

	OpInvert               Operator = "!"  // Reverses the truthiness of a value.
	OpTruth                Operator = "!!" // Determines the truthiness of a value.
	OpEitherTrueAndNotNull Operator = "??" // Check whether either of two values are truthy and not NULL.
	OpEitherTrue           Operator = "?:" // Check whether either of two values are truthy.

	OpContains     Operator = "∋" // ("CONTAINS") Checks whether a value contains another value.
	OpContainsNot  Operator = "∌" // ("CONTAINSNOT") Checks whether a value does not contain another value.
	OpContainsAll  Operator = "⊇" // ("CONTAINSALL") Checks whether a value contains all other values.
	OpContainsAny  Operator = "⊃" // ("CONTAINSANY") Checks whether a value contains any other value.
	OpContainsNone Operator = "⊅" // ("CONTAINSNONE") Checks whether a value contains none of the following values.

	OpIn     Operator = "∈" // ("INSIDE") Checks whether a value is contained within another value. - TODO: geo!
	OpNotIn  Operator = "∉" // ("NOTINSIDE" | "NOT IN") Checks whether a value is not contained within another value. - TODO: geo!
	OpAllIn  Operator = "⊆" // ("ALLINSIDE") Checks whether all values are contained within other values.
	OpAnyIn  Operator = "⊂" // ("ANYINSIDE") Checks whether any value is contained within other values.
	OpNoneIn Operator = "⊄" // ("NONEINSIDE") Checks whether no value is contained within other values.

	OpGeoOutside    Operator = "OUTSIDE"    // Checks whether a geometry type is outside another geometry type.
	OpGeoIntersects Operator = "INTERSECTS" // Checks whether a geometry type intersects another geometry type.

	OpSearch Operator = "@@" // ("@[ref]@") Checks whether the terms are found in a full-text indexed field. - TODO!

	OpX = "<|4|> or <|3,HAMMING|>" // KNN - TODO!

	CastInt   Operator = "<int>"
	CastFloat Operator = "<float>"

	OpModulo Operator = "%" // https://github.com/surrealdb/surrealdb/pull/4182
)

func renderScoreCombination(refs []int, mode ScoreCombineMode, weights []float64) string {
	var scoreParts []string
	for _, ref := range refs {
		scoreParts = append(scoreParts, "search::score("+strconv.Itoa(ref)+")")
	}

	switch mode {
	case ScoreCombineMax:
		return "math::max(" + strings.Join(scoreParts, ", ") + ")"
	case ScoreCombineAverage:
		return "((" + strings.Join(scoreParts, " + ") + ") / " + strconv.Itoa(len(refs)) + ")"
	case ScoreCombineWeighted:
		var weightedParts []string
		for i, ref := range refs {
			weightedParts = append(weightedParts,
				"search::score("+strconv.Itoa(ref)+") * "+strconv.FormatFloat(weights[i], 'f', -1, 64))
		}
		return "(" + strings.Join(weightedParts, " + ") + ")"
	default: // ScoreCombineSum
		return "(" + strings.Join(scoreParts, " + ") + ")"
	}
}

//
// -- HELPER
//

var letterDef = [...]string{
	"A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M",
	"N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z",
}

func intToLetters(number int32) (letters string) {
	if firstLetter := number / 26; firstLetter > 0 {
		letters += intToLetters(firstLetter)
		letters += letterDef[number%26]
		return
	}

	letters += letterDef[number]
	return
}
