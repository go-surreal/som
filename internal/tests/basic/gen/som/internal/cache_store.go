// Code generated by github.com/go-surreal/som, DO NOT EDIT.

package internal

import (
	"strconv"
	"sync"
	"sync/atomic"
)

var (
	cacheStoreMu     sync.RWMutex
	cacheStores      = make(map[string]any)
	cacheKeyRegistry = make(map[string]string)        // cacheID â†’ fullKey
	droppedCacheIDs  = make(map[string]struct{})      // tracks cleaned-up cache IDs
	cacheCounter     atomic.Uint64
)

// NextCacheID generates a unique cache instance ID.
func NextCacheID() string {
	return strconv.FormatUint(cacheCounter.Add(1), 36)
}

// CacheKey builds the cache store key from table name and instance ID.
func CacheKey(table, id string) string {
	return table + ":" + id
}

// RegisterCacheKey maps a cache ID to its full key.
// Called by repo when creating a cache.
func RegisterCacheKey(cacheID, fullKey string) {
	cacheStoreMu.Lock()
	defer cacheStoreMu.Unlock()
	cacheKeyRegistry[cacheID] = fullKey
}

// GetCache retrieves the cache for the given key.
func GetCache(key string) (any, bool) {
	cacheStoreMu.RLock()
	defer cacheStoreMu.RUnlock()
	c, ok := cacheStores[key]
	return c, ok
}

// SetCache stores the cache for the given key.
func SetCache(key string, cache any) {
	cacheStoreMu.Lock()
	defer cacheStoreMu.Unlock()
	cacheStores[key] = cache
}

// DropCacheByID drops the cache for the given cache ID.
// Looks up the full key from the registry.
func DropCacheByID(cacheID string) {
	cacheStoreMu.Lock()
	defer cacheStoreMu.Unlock()
	if fullKey, ok := cacheKeyRegistry[cacheID]; ok {
		delete(cacheStores, fullKey)
		delete(cacheKeyRegistry, cacheID)
	}
	droppedCacheIDs[cacheID] = struct{}{}
}

// IsCacheDropped returns true if the cache ID was previously dropped.
// This is used to detect attempts to use a cleaned-up cache.
func IsCacheDropped(cacheID string) bool {
	cacheStoreMu.RLock()
	defer cacheStoreMu.RUnlock()
	_, dropped := droppedCacheIDs[cacheID]
	return dropped
}
