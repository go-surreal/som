// Code generated by github.com/go-surreal/som, DO NOT EDIT.
package cbor

import (
	cbor "github.com/fxamacker/cbor/v2"
	"github.com/google/uuid"
	"github.com/surrealdb/surrealdb.go/pkg/models"
	"net/url"
	"time"
)

const (
	tagDatetime = 12
	tagDuration = 14
	nanosecond  = 1e+09
)

// DateTime marshaling helpers
func MarshalDateTime(t time.Time) (cbor.RawMessage, error) {
	content, err := cbor.Marshal([]int64{t.Unix(), int64(t.Nanosecond())})
	if err != nil {
		return nil, err
	}
	return cbor.Marshal(cbor.RawTag{
		Content: content,
		Number:  tagDatetime,
	})
}

func MarshalDateTimePtr(t *time.Time) (cbor.RawMessage, error) {
	if t == nil {
		return cbor.Marshal(nil)
	}
	return MarshalDateTime(*t)
}

func UnmarshalDateTime(data []byte) (time.Time, error) {
	var val []int64
	if err := cbor.Unmarshal(data, &val); err != nil {
		return time.Time{}, err
	}
	if len(val) == 0 {
		return time.Time{}, nil
	}
	secs := val[0]
	nano := int64(0)
	if len(val) > 1 {
		nano = val[1]
	}
	return time.Unix(secs, nano), nil
}

func UnmarshalDateTimePtr(data []byte) (*time.Time, error) {
	t, err := UnmarshalDateTime(data)
	if err != nil {
		return nil, err
	}
	return &t, nil
}

// Duration marshaling helpers
func MarshalDuration(d time.Duration) (cbor.RawMessage, error) {
	totalSeconds := int64(d.Seconds())
	totalNanoseconds := d.Nanoseconds()
	remainingNanoseconds := totalNanoseconds - (totalSeconds * nanosecond)
	content, err := cbor.Marshal([]int64{totalSeconds, remainingNanoseconds})
	if err != nil {
		return nil, err
	}
	return cbor.Marshal(cbor.RawTag{
		Content: content,
		Number:  tagDuration,
	})
}

func MarshalDurationPtr(d *time.Duration) (cbor.RawMessage, error) {
	if d == nil {
		return cbor.Marshal(nil)
	}
	return MarshalDuration(*d)
}

func UnmarshalDuration(data []byte) (time.Duration, error) {
	var val []int64
	if err := cbor.Unmarshal(data, &val); err != nil {
		return 0, err
	}
	var dur time.Duration
	if len(val) > 0 {
		dur = time.Duration(val[0]) * time.Second
	}
	if len(val) > 1 {
		dur += time.Duration(val[1])
	}
	return dur, nil
}

func UnmarshalDurationPtr(data []byte) (*time.Duration, error) {
	d, err := UnmarshalDuration(data)
	if err != nil {
		return nil, err
	}
	return &d, nil
}

// UUID marshaling helpers
func MarshalUUID(u uuid.UUID) (cbor.RawMessage, error) {
	raw, err := cbor.Marshal(u)
	if err != nil {
		return nil, err
	}
	return cbor.Marshal(cbor.RawTag{
		Content: raw,
		Number:  models.TagSpecBinaryUUID,
	})
}

func MarshalUUIDPtr(u *uuid.UUID) (cbor.RawMessage, error) {
	if u == nil {
		return cbor.Marshal(nil)
	}
	return MarshalUUID(*u)
}

func UnmarshalUUID(data []byte) (uuid.UUID, error) {
	var tag cbor.RawTag
	if err := cbor.Unmarshal(data, &tag); err != nil {
		return uuid.UUID{}, err
	}
	var uuidBytes []byte
	if err := cbor.Unmarshal(tag.Content, &uuidBytes); err != nil {
		return uuid.UUID{}, err
	}
	return uuid.FromBytes(uuidBytes)
}

func UnmarshalUUIDPtr(data []byte) (*uuid.UUID, error) {
	u, err := UnmarshalUUID(data)
	if err != nil {
		return nil, err
	}
	return &u, nil
}

// URL marshaling helpers
func MarshalURL(u url.URL) string {
	return u.String()
}

func MarshalURLPtr(u *url.URL) *string {
	if u == nil {
		return nil
	}
	s := u.String()
	return &s
}

func UnmarshalURL(s string) (url.URL, error) {
	u, err := url.Parse(s)
	if err != nil {
		return url.URL{}, err
	}
	return *u, nil
}

func UnmarshalURLPtr(s *string) (*url.URL, error) {
	if s == nil {
		return nil, nil
	}
	u, err := url.Parse(*s)
	if err != nil {
		return nil, err
	}
	return u, nil
}
