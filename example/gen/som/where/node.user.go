// Code generated by github.com/marcbinz/som, DO NOT EDIT.
package where

import (
	uuid "github.com/google/uuid"
	model "github.com/marcbinz/som/example/model"
	filter "github.com/marcbinz/som/lib/filter"
)

var User = newUser[model.User](filter.NewKey())

func newUser[T any](key filter.Key) user[T] {
	return user[T]{
		Bool:      filter.NewBool[T](key.Dot("bool")),
		Bool2:     filter.NewBool[T](key.Dot("bool_2")),
		CreatedAt: filter.NewTime[T](key.Dot("created_at")),
		Float32:   filter.NewNumeric[float32, T](key.Dot("float_32")),
		Float64:   filter.NewNumeric[float64, T](key.Dot("float_64")),
		ID:        filter.NewID[T](key.Dot("id"), "user"),
		Int:       filter.NewNumeric[int, T](key.Dot("int")),
		Int32:     filter.NewNumeric[int32, T](key.Dot("int_32")),
		Int64:     filter.NewNumeric[int64, T](key.Dot("int_64")),
		IntPtr:    filter.NewNumericPtr[*int, T](key.Dot("int_ptr")),
		Role:      filter.NewBase[model.Role, T](key.Dot("role")),
		String:    filter.NewString[T](key.Dot("string")),
		StringPtr: filter.NewStringPtr[T](key.Dot("string_ptr")),
		TimePtr:   filter.NewTimePtr[T](key.Dot("time_ptr")),
		UUID:      filter.NewBase[uuid.UUID, T](key.Dot("uuid")),
		UpdatedAt: filter.NewTime[T](key.Dot("updated_at")),
		UuidPtr:   filter.NewBasePtr[uuid.UUID, T](key.Dot("uuid_ptr")),
		key:       key,
	}
}

type user[T any] struct {
	key       filter.Key
	ID        *filter.ID[T]
	CreatedAt *filter.Time[T]
	UpdatedAt *filter.Time[T]
	String    *filter.String[T]
	Int       *filter.Numeric[int, T]
	Int32     *filter.Numeric[int32, T]
	Int64     *filter.Numeric[int64, T]
	Float32   *filter.Numeric[float32, T]
	Float64   *filter.Numeric[float64, T]
	Bool      *filter.Bool[T]
	Bool2     *filter.Bool[T]
	UUID      *filter.Base[uuid.UUID, T]
	Role      *filter.Base[model.Role, T]
	StringPtr *filter.StringPtr[T]
	IntPtr    *filter.NumericPtr[*int, T]
	TimePtr   *filter.TimePtr[T]
	UuidPtr   *filter.BasePtr[uuid.UUID, T]
}
type userSlice[T any] struct {
	user[T]
	*filter.Slice[T, model.User]
}

func (n user[T]) Login() login[T] {
	return newLogin[T](n.key.Dot("login"))
}
func (n user[T]) Groups(filters ...filter.Of[model.Group]) groupSlice[T] {
	key := n.key.Dot("groups")
	return groupSlice[T]{newGroup[T](key), filter.NewSlice[T, model.Group](key, filters)}
}
func (n user[T]) MainGroup() group[T] {
	return newGroup[T](n.key.Dot("main_group"))
}
func (n user[T]) Other() *filter.Slice[T, string] {
	return filter.NewSlice[T, string](n.key.Dot("other"), nil)
}
func (n user[T]) More() *filter.Slice[T, float32] {
	return filter.NewSlice[T, float32](n.key.Dot("more"), nil)
}
func (n user[T]) Roles() *filter.Slice[T, model.Role] {
	return filter.NewSlice[T, model.Role](n.key.Dot("roles"), nil)
}
func (n user[T]) MyGroups(filters ...filter.Of[model.MemberOf]) memberOfIn[T] {
	return newMemberOfIn[T](n.key.In("member_of", filters))
}
func (n user[T]) StructPtr() someStruct[T] {
	return newSomeStruct[T](n.key.Dot("struct_ptr"))
}
func (n user[T]) StringPtrSlice() *filter.Slice[T, *string] {
	return filter.NewSlice[T, *string](n.key.Dot("string_ptr_slice"), nil)
}
func (n user[T]) StringSlicePtr() *filter.Slice[T, string] {
	return filter.NewSlice[T, string](n.key.Dot("string_slice_ptr"), nil)
}
func (n user[T]) StructPtrSlice() *filter.Slice[T, *model.SomeStruct] {
	return filter.NewSlice[T, *model.SomeStruct](n.key.Dot("struct_ptr_slice"), nil)
}
func (n user[T]) StructPtrSlicePtr() *filter.Slice[T, *model.SomeStruct] {
	return filter.NewSlice[T, *model.SomeStruct](n.key.Dot("struct_ptr_slice_ptr"), nil)
}
func (n user[T]) EnumPtrSlice() *filter.Slice[T, model.Role] {
	return filter.NewSlice[T, model.Role](n.key.Dot("enum_ptr_slice"), nil)
}
func (n user[T]) NodePtrSlice(filters ...filter.Of[model.Group]) groupSlice[T] {
	key := n.key.Dot("node_ptr_slice")
	return groupSlice[T]{newGroup[T](key), filter.NewSlice[T, model.Group](key, filters)}
}
func (n user[T]) NodePtrSlicePtr(filters ...filter.Of[model.Group]) groupSlice[T] {
	key := n.key.Dot("node_ptr_slice_ptr")
	return groupSlice[T]{newGroup[T](key), filter.NewSlice[T, model.Group](key, filters)}
}
func (n user[T]) SliceSlice() *filter.Slice[T, []string] {
	return filter.NewSlice[T, []string](n.key.Dot("slice_slice"), nil)
}
