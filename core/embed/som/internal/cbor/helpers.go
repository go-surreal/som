// Code generated by github.com/go-surreal/som, DO NOT EDIT.
package cbor

import (
	"fmt"
	"time"
)

const (
	tagDatetime = 12
	tagDuration = 14
	nanosecond  = 1e+09
)

// DateTime marshaling helpers
func MarshalDateTime(t time.Time) (RawMessage, error) {
	content, err := Marshal([]int64{t.Unix(), int64(t.Nanosecond())})
	if err != nil {
		return nil, err
	}
	return Marshal(RawTag{
		Content: content,
		Number:  tagDatetime,
	})
}

func MarshalDateTimePtr(t *time.Time) (RawMessage, error) {
	if t == nil {
		return Marshal(nil)
	}
	return MarshalDateTime(*t)
}

func UnmarshalDateTime(data []byte) (time.Time, error) {
	var val []int64
	if err := Unmarshal(data, &val); err != nil {
		return time.Time{}, err
	}
	if len(val) == 0 {
		return time.Time{}, nil
	}
	secs := val[0]
	nano := int64(0)
	if len(val) > 1 {
		nano = val[1]
	}
	return time.Unix(secs, nano), nil
}

func UnmarshalDateTimePtr(data []byte) (*time.Time, error) {
	t, err := UnmarshalDateTime(data)
	if err != nil {
		return nil, err
	}
	return &t, nil
}

// Duration marshaling helpers
func MarshalDuration(d time.Duration) (RawMessage, error) {
	totalSeconds := int64(d.Seconds())
	totalNanoseconds := d.Nanoseconds()
	remainingNanoseconds := totalNanoseconds - (totalSeconds * nanosecond)
	content, err := Marshal([]int64{totalSeconds, remainingNanoseconds})
	if err != nil {
		return nil, err
	}
	return Marshal(RawTag{
		Content: content,
		Number:  tagDuration,
	})
}

func MarshalDurationPtr(d *time.Duration) (RawMessage, error) {
	if d == nil {
		return Marshal(nil)
	}
	return MarshalDuration(*d)
}

func UnmarshalDuration(data []byte) (time.Duration, error) {
	var val []int64
	if err := Unmarshal(data, &val); err != nil {
		return 0, err
	}
	var dur time.Duration
	if len(val) > 0 {
		dur = time.Duration(val[0]) * time.Second
	}
	if len(val) > 1 {
		dur += time.Duration(val[1])
	}
	return dur, nil
}

func UnmarshalDurationPtr(data []byte) (*time.Duration, error) {
	d, err := UnmarshalDuration(data)
	if err != nil {
		return nil, err
	}
	return &d, nil
}

func RecordIDToString(id any) (string, error) {
	switch v := id.(type) {
	case string:
		return v, nil
	case Tag:
		if v.Number == 37 {
			uuidBytes, ok := v.Content.([]byte)
			if !ok {
				return "", fmt.Errorf("expected []byte UUID content, got %T", v.Content)
			}
			if len(uuidBytes) != 16 {
				return "", fmt.Errorf("UUID must be 16 bytes, got %d", len(uuidBytes))
			}
			return fmt.Sprintf("%08x-%04x-%04x-%04x-%012x",
				uuidBytes[0:4], uuidBytes[4:6], uuidBytes[6:8], uuidBytes[8:10], uuidBytes[10:16]), nil
		}
		return "", fmt.Errorf("unsupported CBOR tag %d in record ID", v.Number)
	default:
		return "", fmt.Errorf("expected string or tagged ID, got %T", id)
	}
}

