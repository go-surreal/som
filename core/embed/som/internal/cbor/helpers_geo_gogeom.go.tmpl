//go:build embed

package cbor

import (
	"github.com/surrealdb/surrealdb.go/pkg/models"
	"github.com/twpayne/go-geom"
)

// Point helpers

func UnmarshalPointGG(data []byte) (geom.Point, error) {
	var coords [2]float64
	if err := Unmarshal(data, &coords); err != nil {
		return geom.Point{}, err
	}
	return *geom.NewPointFlat(geom.XY, coords[:]), nil
}

func UnmarshalPointGGPtr(data []byte) (*geom.Point, error) {
	var coords [2]float64
	if err := Unmarshal(data, &coords); err != nil {
		return nil, err
	}
	return geom.NewPointFlat(geom.XY, coords[:]), nil
}

// LineString helpers

func UnmarshalLineStringGG(data []byte) (geom.LineString, error) {
	var coords [][2]float64
	if err := Unmarshal(data, &coords); err != nil {
		return geom.LineString{}, err
	}
	flat := make([]float64, len(coords)*2)
	for i, c := range coords {
		flat[i*2] = c[0]
		flat[i*2+1] = c[1]
	}
	return *geom.NewLineStringFlat(geom.XY, flat), nil
}

func UnmarshalLineStringGGPtr(data []byte) (*geom.LineString, error) {
	var coords [][2]float64
	if err := Unmarshal(data, &coords); err != nil {
		return nil, err
	}
	flat := make([]float64, len(coords)*2)
	for i, c := range coords {
		flat[i*2] = c[0]
		flat[i*2+1] = c[1]
	}
	return geom.NewLineStringFlat(geom.XY, flat), nil
}

// Polygon helpers

func UnmarshalPolygonGG(data []byte) (geom.Polygon, error) {
	var rings [][][2]float64
	if err := Unmarshal(data, &rings); err != nil {
		return geom.Polygon{}, err
	}
	if len(rings) == 0 {
		return *geom.NewPolygon(geom.XY), nil
	}
	var flat []float64
	ends := make([]int, len(rings))
	for i, ring := range rings {
		for _, c := range ring {
			flat = append(flat, c[0], c[1])
		}
		ends[i] = len(flat) / 2
	}
	return *geom.NewPolygonFlat(geom.XY, flat, ends), nil
}

func UnmarshalPolygonGGPtr(data []byte) (*geom.Polygon, error) {
	var rings [][][2]float64
	if err := Unmarshal(data, &rings); err != nil {
		return nil, err
	}
	if len(rings) == 0 {
		return geom.NewPolygon(geom.XY), nil
	}
	var flat []float64
	ends := make([]int, len(rings))
	for i, ring := range rings {
		for _, c := range ring {
			flat = append(flat, c[0], c[1])
		}
		ends[i] = len(flat) / 2
	}
	return geom.NewPolygonFlat(geom.XY, flat, ends), nil
}

// MultiPoint helpers

func UnmarshalMultiPointGG(data []byte) (geom.MultiPoint, error) {
	var coords [][2]float64
	if err := Unmarshal(data, &coords); err != nil {
		return geom.MultiPoint{}, err
	}
	flat := make([]float64, len(coords)*2)
	for i, c := range coords {
		flat[i*2] = c[0]
		flat[i*2+1] = c[1]
	}
	return *geom.NewMultiPointFlat(geom.XY, flat), nil
}

func UnmarshalMultiPointGGPtr(data []byte) (*geom.MultiPoint, error) {
	var coords [][2]float64
	if err := Unmarshal(data, &coords); err != nil {
		return nil, err
	}
	flat := make([]float64, len(coords)*2)
	for i, c := range coords {
		flat[i*2] = c[0]
		flat[i*2+1] = c[1]
	}
	return geom.NewMultiPointFlat(geom.XY, flat), nil
}

// MultiLineString helpers

func UnmarshalMultiLineStringGG(data []byte) (geom.MultiLineString, error) {
	var lines [][][2]float64
	if err := Unmarshal(data, &lines); err != nil {
		return geom.MultiLineString{}, err
	}
	var flat []float64
	ends := make([]int, len(lines))
	for i, line := range lines {
		for _, c := range line {
			flat = append(flat, c[0], c[1])
		}
		ends[i] = len(flat) / 2
	}
	return *geom.NewMultiLineStringFlat(geom.XY, flat, ends), nil
}

func UnmarshalMultiLineStringGGPtr(data []byte) (*geom.MultiLineString, error) {
	var lines [][][2]float64
	if err := Unmarshal(data, &lines); err != nil {
		return nil, err
	}
	var flat []float64
	ends := make([]int, len(lines))
	for i, line := range lines {
		for _, c := range line {
			flat = append(flat, c[0], c[1])
		}
		ends[i] = len(flat) / 2
	}
	return geom.NewMultiLineStringFlat(geom.XY, flat, ends), nil
}

// MultiPolygon helpers

func UnmarshalMultiPolygonGG(data []byte) (geom.MultiPolygon, error) {
	var polys [][][][2]float64
	if err := Unmarshal(data, &polys); err != nil {
		return geom.MultiPolygon{}, err
	}
	var flat []float64
	var endss [][]int
	for _, poly := range polys {
		var polyEnds []int
		for _, ring := range poly {
			for _, c := range ring {
				flat = append(flat, c[0], c[1])
			}
			polyEnds = append(polyEnds, len(flat)/2)
		}
		endss = append(endss, polyEnds)
	}
	return *geom.NewMultiPolygonFlat(geom.XY, flat, endss), nil
}

func UnmarshalMultiPolygonGGPtr(data []byte) (*geom.MultiPolygon, error) {
	var polys [][][][2]float64
	if err := Unmarshal(data, &polys); err != nil {
		return nil, err
	}
	var flat []float64
	var endss [][]int
	for _, poly := range polys {
		var polyEnds []int
		for _, ring := range poly {
			for _, c := range ring {
				flat = append(flat, c[0], c[1])
			}
			polyEnds = append(polyEnds, len(flat)/2)
		}
		endss = append(endss, polyEnds)
	}
	return geom.NewMultiPolygonFlat(geom.XY, flat, endss), nil
}

// GeometryCollection helpers

func UnmarshalCollectionGG(data []byte) (geom.GeometryCollection, error) {
	gc, err := unmarshalCollectionGG(data)
	if err != nil {
		return geom.GeometryCollection{}, err
	}
	return *gc, nil
}

func UnmarshalCollectionGGPtr(data []byte) (*geom.GeometryCollection, error) {
	return unmarshalCollectionGG(data)
}

func unmarshalCollectionGG(data []byte) (*geom.GeometryCollection, error) {
	var geometries []RawMessage
	if err := Unmarshal(data, &geometries); err != nil {
		return nil, err
	}
	gc := geom.NewGeometryCollection()
	for _, raw := range geometries {
		var tag RawTag
		if err := Unmarshal(raw, &tag); err != nil {
			continue
		}
		switch tag.Number {
		case models.TagGeometryPoint:
			var coords [2]float64
			if err := Unmarshal(tag.Content, &coords); err == nil {
				gc.MustPush(geom.NewPointFlat(geom.XY, coords[:]))
			}
		case models.TagGeometryLine:
			var coords [][2]float64
			if err := Unmarshal(tag.Content, &coords); err == nil {
				flat := make([]float64, len(coords)*2)
				for i, c := range coords {
					flat[i*2] = c[0]
					flat[i*2+1] = c[1]
				}
				gc.MustPush(geom.NewLineStringFlat(geom.XY, flat))
			}
		case models.TagGeometryPolygon:
			var rings [][][2]float64
			if err := Unmarshal(tag.Content, &rings); err == nil {
				var flat []float64
				ends := make([]int, len(rings))
				for i, ring := range rings {
					for _, c := range ring {
						flat = append(flat, c[0], c[1])
					}
					ends[i] = len(flat) / 2
				}
				gc.MustPush(geom.NewPolygonFlat(geom.XY, flat, ends))
			}
		case models.TagGeometryMultiPoint:
			var coords [][2]float64
			if err := Unmarshal(tag.Content, &coords); err == nil {
				flat := make([]float64, len(coords)*2)
				for i, c := range coords {
					flat[i*2] = c[0]
					flat[i*2+1] = c[1]
				}
				gc.MustPush(geom.NewMultiPointFlat(geom.XY, flat))
			}
		case models.TagGeometryMultiLine:
			var lines [][][2]float64
			if err := Unmarshal(tag.Content, &lines); err == nil {
				var flat []float64
				ends := make([]int, len(lines))
				for i, line := range lines {
					for _, c := range line {
						flat = append(flat, c[0], c[1])
					}
					ends[i] = len(flat) / 2
				}
				gc.MustPush(geom.NewMultiLineStringFlat(geom.XY, flat, ends))
			}
		case models.TagGeometryMultiPolygon:
			var polys [][][][2]float64
			if err := Unmarshal(tag.Content, &polys); err == nil {
				var flat []float64
				var endss [][]int
				for _, poly := range polys {
					var polyEnds []int
					for _, ring := range poly {
						for _, c := range ring {
							flat = append(flat, c[0], c[1])
						}
						polyEnds = append(polyEnds, len(flat)/2)
					}
					endss = append(endss, polyEnds)
				}
				gc.MustPush(geom.NewMultiPolygonFlat(geom.XY, flat, endss))
			}
		}
	}
	return gc, nil
}
