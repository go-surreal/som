//go:build embed

package cbor

import (
	"github.com/peterstace/simplefeatures/geom"
	"github.com/surrealdb/surrealdb.go/pkg/models"
)

// Point helpers

func UnmarshalPointSF(data []byte) (geom.Point, error) {
	var coords [2]float64
	if err := Unmarshal(data, &coords); err != nil {
		return geom.Point{}, err
	}
	return geom.NewPoint(geom.Coordinates{XY: geom.XY{X: coords[0], Y: coords[1]}}), nil
}

func UnmarshalPointSFPtr(data []byte) (*geom.Point, error) {
	p, err := UnmarshalPointSF(data)
	if err != nil {
		return nil, err
	}
	return &p, nil
}

// LineString helpers

func sfNewLineString(flat []float64) geom.LineString {
	return geom.NewLineString(geom.NewSequence(flat, geom.DimXY))
}

func UnmarshalLineStringSF(data []byte) (geom.LineString, error) {
	var coords [][2]float64
	if err := Unmarshal(data, &coords); err != nil {
		return geom.LineString{}, err
	}
	flat := make([]float64, 0, len(coords)*2)
	for _, c := range coords {
		flat = append(flat, c[0], c[1])
	}
	return sfNewLineString(flat), nil
}

func UnmarshalLineStringSFPtr(data []byte) (*geom.LineString, error) {
	l, err := UnmarshalLineStringSF(data)
	if err != nil {
		return nil, err
	}
	return &l, nil
}

// Polygon helpers

func sfNewPolygon(rings []geom.LineString) geom.Polygon {
	return geom.NewPolygon(rings)
}

func UnmarshalPolygonSF(data []byte) (geom.Polygon, error) {
	var rings [][][2]float64
	if err := Unmarshal(data, &rings); err != nil {
		return geom.Polygon{}, err
	}
	lsRings := make([]geom.LineString, len(rings))
	for i, ring := range rings {
		flat := make([]float64, 0, len(ring)*2)
		for _, c := range ring {
			flat = append(flat, c[0], c[1])
		}
		lsRings[i] = sfNewLineString(flat)
	}
	return sfNewPolygon(lsRings), nil
}

func UnmarshalPolygonSFPtr(data []byte) (*geom.Polygon, error) {
	p, err := UnmarshalPolygonSF(data)
	if err != nil {
		return nil, err
	}
	return &p, nil
}

// MultiPoint helpers

func UnmarshalMultiPointSF(data []byte) (geom.MultiPoint, error) {
	var coords [][2]float64
	if err := Unmarshal(data, &coords); err != nil {
		return geom.MultiPoint{}, err
	}
	points := make([]geom.Point, len(coords))
	for i, c := range coords {
		points[i] = geom.NewPoint(geom.Coordinates{XY: geom.XY{X: c[0], Y: c[1]}})
	}
	return geom.NewMultiPoint(points), nil
}

func UnmarshalMultiPointSFPtr(data []byte) (*geom.MultiPoint, error) {
	m, err := UnmarshalMultiPointSF(data)
	if err != nil {
		return nil, err
	}
	return &m, nil
}

// MultiLineString helpers

func UnmarshalMultiLineStringSF(data []byte) (geom.MultiLineString, error) {
	var lines [][][2]float64
	if err := Unmarshal(data, &lines); err != nil {
		return geom.MultiLineString{}, err
	}
	lineStrings := make([]geom.LineString, len(lines))
	for i, line := range lines {
		flat := make([]float64, 0, len(line)*2)
		for _, c := range line {
			flat = append(flat, c[0], c[1])
		}
		lineStrings[i] = sfNewLineString(flat)
	}
	return geom.NewMultiLineString(lineStrings), nil
}

func UnmarshalMultiLineStringSFPtr(data []byte) (*geom.MultiLineString, error) {
	m, err := UnmarshalMultiLineStringSF(data)
	if err != nil {
		return nil, err
	}
	return &m, nil
}

// MultiPolygon helpers

func UnmarshalMultiPolygonSF(data []byte) (geom.MultiPolygon, error) {
	var polys [][][][2]float64
	if err := Unmarshal(data, &polys); err != nil {
		return geom.MultiPolygon{}, err
	}
	polygons := make([]geom.Polygon, len(polys))
	for i, poly := range polys {
		rings := make([]geom.LineString, len(poly))
		for j, ring := range poly {
			flat := make([]float64, 0, len(ring)*2)
			for _, c := range ring {
				flat = append(flat, c[0], c[1])
			}
			rings[j] = sfNewLineString(flat)
		}
		polygons[i] = sfNewPolygon(rings)
	}
	return geom.NewMultiPolygon(polygons), nil
}

func UnmarshalMultiPolygonSFPtr(data []byte) (*geom.MultiPolygon, error) {
	m, err := UnmarshalMultiPolygonSF(data)
	if err != nil {
		return nil, err
	}
	return &m, nil
}

// GeometryCollection helpers

func UnmarshalCollectionSF(data []byte) (geom.GeometryCollection, error) {
	var geometries []RawMessage
	if err := Unmarshal(data, &geometries); err != nil {
		return geom.GeometryCollection{}, err
	}
	geoms := make([]geom.Geometry, 0, len(geometries))
	for _, raw := range geometries {
		var tag RawTag
		if err := Unmarshal(raw, &tag); err != nil {
			continue
		}
		switch tag.Number {
		case models.TagGeometryPoint:
			var coords [2]float64
			if err := Unmarshal(tag.Content, &coords); err == nil {
				pt := geom.NewPoint(geom.Coordinates{XY: geom.XY{X: coords[0], Y: coords[1]}})
				geoms = append(geoms, pt.AsGeometry())
			}
		case models.TagGeometryLine:
			var coords [][2]float64
			if err := Unmarshal(tag.Content, &coords); err == nil {
				flat := make([]float64, 0, len(coords)*2)
				for _, c := range coords {
					flat = append(flat, c[0], c[1])
				}
				ls := sfNewLineString(flat)
				geoms = append(geoms, ls.AsGeometry())
			}
		case models.TagGeometryPolygon:
			var rings [][][2]float64
			if err := Unmarshal(tag.Content, &rings); err == nil {
				lsRings := make([]geom.LineString, len(rings))
				for i, ring := range rings {
					flat := make([]float64, 0, len(ring)*2)
					for _, c := range ring {
						flat = append(flat, c[0], c[1])
					}
					lsRings[i] = sfNewLineString(flat)
				}
				poly := sfNewPolygon(lsRings)
				geoms = append(geoms, poly.AsGeometry())
			}
		case models.TagGeometryMultiPoint:
			var coords [][2]float64
			if err := Unmarshal(tag.Content, &coords); err == nil {
				points := make([]geom.Point, len(coords))
				for i, c := range coords {
					points[i] = geom.NewPoint(geom.Coordinates{XY: geom.XY{X: c[0], Y: c[1]}})
				}
				mp := geom.NewMultiPoint(points)
				geoms = append(geoms, mp.AsGeometry())
			}
		case models.TagGeometryMultiLine:
			var lines [][][2]float64
			if err := Unmarshal(tag.Content, &lines); err == nil {
				lineStrings := make([]geom.LineString, len(lines))
				for i, line := range lines {
					flat := make([]float64, 0, len(line)*2)
					for _, c := range line {
						flat = append(flat, c[0], c[1])
					}
					lineStrings[i] = sfNewLineString(flat)
				}
				mls := geom.NewMultiLineString(lineStrings)
				geoms = append(geoms, mls.AsGeometry())
			}
		case models.TagGeometryMultiPolygon:
			var polys [][][][2]float64
			if err := Unmarshal(tag.Content, &polys); err == nil {
				polygons := make([]geom.Polygon, len(polys))
				for i, poly := range polys {
					rings := make([]geom.LineString, len(poly))
					for j, ring := range poly {
						flat := make([]float64, 0, len(ring)*2)
						for _, c := range ring {
							flat = append(flat, c[0], c[1])
						}
						rings[j] = sfNewLineString(flat)
					}
					polygons[i] = sfNewPolygon(rings)
				}
				mp := geom.NewMultiPolygon(polygons)
				geoms = append(geoms, mp.AsGeometry())
			}
		}
	}
	return geom.NewGeometryCollection(geoms), nil
}

func UnmarshalCollectionSFPtr(data []byte) (*geom.GeometryCollection, error) {
	c, err := UnmarshalCollectionSF(data)
	if err != nil {
		return nil, err
	}
	return &c, nil
}
