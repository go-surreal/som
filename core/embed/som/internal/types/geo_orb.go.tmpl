//go:build embed

package types

import (
	cbor "{{.GenerateOutPath}}/internal/cbor"
	"github.com/paulmach/orb"
	"github.com/surrealdb/surrealdb.go/pkg/models"
)

// PointOrb wraps orb.Point for CBOR marshaling.
type PointOrb orb.Point

func (p *PointOrb) MarshalCBOR() ([]byte, error) {
	if p == nil {
		return cbor.Marshal(nil)
	}
	coords := [2]float64{(*p)[0], (*p)[1]}
	raw, err := cbor.Marshal(coords)
	if err != nil {
		return nil, err
	}
	return cbor.Marshal(cbor.RawTag{Number: models.TagGeometryPoint, Content: raw})
}

func (p *PointOrb) UnmarshalCBOR(data []byte) error {
	var coords [2]float64
	if err := cbor.Unmarshal(data, &coords); err != nil {
		return err
	}
	*p = PointOrb{coords[0], coords[1]}
	return nil
}

// LineStringOrb wraps orb.LineString for CBOR marshaling.
type LineStringOrb orb.LineString

func (l *LineStringOrb) MarshalCBOR() ([]byte, error) {
	if l == nil {
		return cbor.Marshal(nil)
	}
	// LineString must contain an array of tagged Points (Tag 88)
	points := make([]*PointOrb, len(*l))
	for i, pt := range *l {
		p := PointOrb(pt)
		points[i] = &p
	}
	raw, err := cbor.Marshal(points)
	if err != nil {
		return nil, err
	}
	return cbor.Marshal(cbor.RawTag{Number: models.TagGeometryLine, Content: raw})
}

func (l *LineStringOrb) UnmarshalCBOR(data []byte) error {
	var coords [][2]float64
	if err := cbor.Unmarshal(data, &coords); err != nil {
		return err
	}
	points := make(orb.LineString, len(coords))
	for i, c := range coords {
		points[i] = orb.Point{c[0], c[1]}
	}
	*l = LineStringOrb(points)
	return nil
}

// PolygonOrb wraps orb.Polygon for CBOR marshaling.
type PolygonOrb orb.Polygon

func (p *PolygonOrb) MarshalCBOR() ([]byte, error) {
	if p == nil {
		return cbor.Marshal(nil)
	}
	// Polygon must contain an array of tagged LineStrings (Tag 89)
	rings := make([]*LineStringOrb, len(*p))
	for i, ring := range *p {
		ls := LineStringOrb(ring)
		rings[i] = &ls
	}
	raw, err := cbor.Marshal(rings)
	if err != nil {
		return nil, err
	}
	return cbor.Marshal(cbor.RawTag{Number: models.TagGeometryPolygon, Content: raw})
}

func (p *PolygonOrb) UnmarshalCBOR(data []byte) error {
	var rings [][][2]float64
	if err := cbor.Unmarshal(data, &rings); err != nil {
		return err
	}
	polygon := make(orb.Polygon, len(rings))
	for i, ring := range rings {
		points := make(orb.Ring, len(ring))
		for j, c := range ring {
			points[j] = orb.Point{c[0], c[1]}
		}
		polygon[i] = points
	}
	*p = PolygonOrb(polygon)
	return nil
}

// MultiPointOrb wraps orb.MultiPoint for CBOR marshaling.
type MultiPointOrb orb.MultiPoint

func (m *MultiPointOrb) MarshalCBOR() ([]byte, error) {
	if m == nil {
		return cbor.Marshal(nil)
	}
	// MultiPoint must contain an array of tagged Points (Tag 88)
	points := make([]*PointOrb, len(*m))
	for i, pt := range *m {
		p := PointOrb(pt)
		points[i] = &p
	}
	raw, err := cbor.Marshal(points)
	if err != nil {
		return nil, err
	}
	return cbor.Marshal(cbor.RawTag{Number: models.TagGeometryMultiPoint, Content: raw})
}

func (m *MultiPointOrb) UnmarshalCBOR(data []byte) error {
	var coords [][2]float64
	if err := cbor.Unmarshal(data, &coords); err != nil {
		return err
	}
	points := make(orb.MultiPoint, len(coords))
	for i, c := range coords {
		points[i] = orb.Point{c[0], c[1]}
	}
	*m = MultiPointOrb(points)
	return nil
}

// MultiLineStringOrb wraps orb.MultiLineString for CBOR marshaling.
type MultiLineStringOrb orb.MultiLineString

func (m *MultiLineStringOrb) MarshalCBOR() ([]byte, error) {
	if m == nil {
		return cbor.Marshal(nil)
	}
	// MultiLineString must contain an array of tagged LineStrings (Tag 89)
	lines := make([]*LineStringOrb, len(*m))
	for i, line := range *m {
		ls := LineStringOrb(line)
		lines[i] = &ls
	}
	raw, err := cbor.Marshal(lines)
	if err != nil {
		return nil, err
	}
	return cbor.Marshal(cbor.RawTag{Number: models.TagGeometryMultiLine, Content: raw})
}

func (m *MultiLineStringOrb) UnmarshalCBOR(data []byte) error {
	var lines [][][2]float64
	if err := cbor.Unmarshal(data, &lines); err != nil {
		return err
	}
	multiLine := make(orb.MultiLineString, len(lines))
	for i, line := range lines {
		points := make(orb.LineString, len(line))
		for j, c := range line {
			points[j] = orb.Point{c[0], c[1]}
		}
		multiLine[i] = points
	}
	*m = MultiLineStringOrb(multiLine)
	return nil
}

// MultiPolygonOrb wraps orb.MultiPolygon for CBOR marshaling.
type MultiPolygonOrb orb.MultiPolygon

func (m *MultiPolygonOrb) MarshalCBOR() ([]byte, error) {
	if m == nil {
		return cbor.Marshal(nil)
	}
	// MultiPolygon must contain an array of tagged Polygons (Tag 90)
	polys := make([]*PolygonOrb, len(*m))
	for i, poly := range *m {
		p := PolygonOrb(poly)
		polys[i] = &p
	}
	raw, err := cbor.Marshal(polys)
	if err != nil {
		return nil, err
	}
	return cbor.Marshal(cbor.RawTag{Number: models.TagGeometryMultiPolygon, Content: raw})
}

func (m *MultiPolygonOrb) UnmarshalCBOR(data []byte) error {
	var polys [][][][2]float64
	if err := cbor.Unmarshal(data, &polys); err != nil {
		return err
	}
	multiPoly := make(orb.MultiPolygon, len(polys))
	for i, poly := range polys {
		polygon := make(orb.Polygon, len(poly))
		for j, ring := range poly {
			points := make(orb.Ring, len(ring))
			for k, c := range ring {
				points[k] = orb.Point{c[0], c[1]}
			}
			polygon[j] = points
		}
		multiPoly[i] = polygon
	}
	*m = MultiPolygonOrb(multiPoly)
	return nil
}

// CollectionOrb wraps orb.Collection for CBOR marshaling.
type CollectionOrb orb.Collection

func (c *CollectionOrb) MarshalCBOR() ([]byte, error) {
	if c == nil {
		return cbor.Marshal(nil)
	}
	geometries := make([]any, len(*c))
	for i, geom := range *c {
		switch g := geom.(type) {
		case orb.Point:
			p := PointOrb(g)
			geometries[i] = &p
		case orb.LineString:
			l := LineStringOrb(g)
			geometries[i] = &l
		case orb.Polygon:
			p := PolygonOrb(g)
			geometries[i] = &p
		case orb.MultiPoint:
			m := MultiPointOrb(g)
			geometries[i] = &m
		case orb.MultiLineString:
			m := MultiLineStringOrb(g)
			geometries[i] = &m
		case orb.MultiPolygon:
			m := MultiPolygonOrb(g)
			geometries[i] = &m
		default:
			geometries[i] = g
		}
	}
	raw, err := cbor.Marshal(geometries)
	if err != nil {
		return nil, err
	}
	return cbor.Marshal(cbor.RawTag{Number: models.TagGeometryCollection, Content: raw})
}

func (c *CollectionOrb) UnmarshalCBOR(data []byte) error {
	var geometries []cbor.RawMessage
	if err := cbor.Unmarshal(data, &geometries); err != nil {
		return err
	}
	collection := make(orb.Collection, 0, len(geometries))
	for _, raw := range geometries {
		var tag cbor.RawTag
		if err := cbor.Unmarshal(raw, &tag); err != nil {
			continue
		}
		switch tag.Number {
		case models.TagGeometryPoint:
			var p PointOrb
			if err := cbor.Unmarshal(tag.Content, &p); err == nil {
				collection = append(collection, orb.Point(p))
			}
		case models.TagGeometryLine:
			var l LineStringOrb
			if err := cbor.Unmarshal(tag.Content, &l); err == nil {
				collection = append(collection, orb.LineString(l))
			}
		case models.TagGeometryPolygon:
			var p PolygonOrb
			if err := cbor.Unmarshal(tag.Content, &p); err == nil {
				collection = append(collection, orb.Polygon(p))
			}
		case models.TagGeometryMultiPoint:
			var m MultiPointOrb
			if err := cbor.Unmarshal(tag.Content, &m); err == nil {
				collection = append(collection, orb.MultiPoint(m))
			}
		case models.TagGeometryMultiLine:
			var m MultiLineStringOrb
			if err := cbor.Unmarshal(tag.Content, &m); err == nil {
				collection = append(collection, orb.MultiLineString(m))
			}
		case models.TagGeometryMultiPolygon:
			var m MultiPolygonOrb
			if err := cbor.Unmarshal(tag.Content, &m); err == nil {
				collection = append(collection, orb.MultiPolygon(m))
			}
		}
	}
	*c = CollectionOrb(collection)
	return nil
}
