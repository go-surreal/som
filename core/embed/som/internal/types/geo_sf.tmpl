//go:build embed

package types

import (
	cbor "{{.GenerateOutPath}}/internal/cbor"
	"github.com/peterstace/simplefeatures/geom"
)

const (
	tagSFGeometryPoint           = 88
	tagSFGeometryLine            = 89
	tagSFGeometryPolygon         = 90
	tagSFGeometryMultiPoint      = 91
	tagSFGeometryMultiLine       = 92
	tagSFGeometryMultiPolygon    = 93
	tagSFGeometryCollection      = 94
)

// PointSF wraps geom.Point for CBOR marshaling.
type PointSF geom.Point

func (p *PointSF) MarshalCBOR() ([]byte, error) {
	if p == nil {
		return cbor.Marshal(nil)
	}
	pt := geom.Point(*p)
	coords, ok := pt.XY()
	if !ok {
		return cbor.Marshal(nil)
	}
	coordArr := [2]float64{coords.X, coords.Y}
	raw, err := cbor.Marshal(coordArr)
	if err != nil {
		return nil, err
	}
	return cbor.Marshal(cbor.RawTag{Number: tagSFGeometryPoint, Content: raw})
}

func (p *PointSF) UnmarshalCBOR(data []byte) error {
	var coords [2]float64
	if err := cbor.Unmarshal(data, &coords); err != nil {
		return err
	}
	pt := geom.NewPoint(geom.Coordinates{XY: geom.XY{X: coords[0], Y: coords[1]}})
	*p = PointSF(pt)
	return nil
}

// LineStringSF wraps geom.LineString for CBOR marshaling.
type LineStringSF geom.LineString

func (l *LineStringSF) MarshalCBOR() ([]byte, error) {
	if l == nil {
		return cbor.Marshal(nil)
	}
	ls := geom.LineString(*l)
	seq := ls.Coordinates()
	n := seq.Length()
	coords := make([][2]float64, n)
	for i := 0; i < n; i++ {
		xy := seq.GetXY(i)
		coords[i] = [2]float64{xy.X, xy.Y}
	}
	raw, err := cbor.Marshal(coords)
	if err != nil {
		return nil, err
	}
	return cbor.Marshal(cbor.RawTag{Number: tagSFGeometryLine, Content: raw})
}

func (l *LineStringSF) UnmarshalCBOR(data []byte) error {
	var coords [][2]float64
	if err := cbor.Unmarshal(data, &coords); err != nil {
		return err
	}
	floats := make([]float64, len(coords)*2)
	for i, c := range coords {
		floats[i*2] = c[0]
		floats[i*2+1] = c[1]
	}
	ls := geom.NewLineString(geom.NewSequence(floats, geom.DimXY))
	*l = LineStringSF(ls)
	return nil
}

// PolygonSF wraps geom.Polygon for CBOR marshaling.
type PolygonSF geom.Polygon

func (p *PolygonSF) MarshalCBOR() ([]byte, error) {
	if p == nil {
		return cbor.Marshal(nil)
	}
	poly := geom.Polygon(*p)
	extRing := poly.ExteriorRing()
	numHoles := poly.NumInteriorRings()

	rings := make([][][2]float64, 1+numHoles)

	extSeq := extRing.Coordinates()
	extN := extSeq.Length()
	extCoords := make([][2]float64, extN)
	for i := 0; i < extN; i++ {
		xy := extSeq.GetXY(i)
		extCoords[i] = [2]float64{xy.X, xy.Y}
	}
	rings[0] = extCoords

	for h := 0; h < numHoles; h++ {
		hole := poly.InteriorRingN(h)
		holeSeq := hole.Coordinates()
		holeN := holeSeq.Length()
		holeCoords := make([][2]float64, holeN)
		for i := 0; i < holeN; i++ {
			xy := holeSeq.GetXY(i)
			holeCoords[i] = [2]float64{xy.X, xy.Y}
		}
		rings[1+h] = holeCoords
	}

	raw, err := cbor.Marshal(rings)
	if err != nil {
		return nil, err
	}
	return cbor.Marshal(cbor.RawTag{Number: tagSFGeometryPolygon, Content: raw})
}

func (p *PolygonSF) UnmarshalCBOR(data []byte) error {
	var rings [][][2]float64
	if err := cbor.Unmarshal(data, &rings); err != nil {
		return err
	}
	if len(rings) == 0 {
		*p = PolygonSF(geom.Polygon{})
		return nil
	}

	lsRings := make([]geom.LineString, len(rings))
	for i, ring := range rings {
		floats := make([]float64, len(ring)*2)
		for j, c := range ring {
			floats[j*2] = c[0]
			floats[j*2+1] = c[1]
		}
		lsRings[i] = geom.NewLineString(geom.NewSequence(floats, geom.DimXY))
	}

	poly := geom.NewPolygon(lsRings)
	*p = PolygonSF(poly)
	return nil
}

// MultiPointSF wraps geom.MultiPoint for CBOR marshaling.
type MultiPointSF geom.MultiPoint

func (m *MultiPointSF) MarshalCBOR() ([]byte, error) {
	if m == nil {
		return cbor.Marshal(nil)
	}
	mp := geom.MultiPoint(*m)
	n := mp.NumPoints()
	coords := make([][2]float64, n)
	for i := 0; i < n; i++ {
		pt := mp.PointN(i)
		xy, ok := pt.XY()
		if ok {
			coords[i] = [2]float64{xy.X, xy.Y}
		}
	}
	raw, err := cbor.Marshal(coords)
	if err != nil {
		return nil, err
	}
	return cbor.Marshal(cbor.RawTag{Number: tagSFGeometryMultiPoint, Content: raw})
}

func (m *MultiPointSF) UnmarshalCBOR(data []byte) error {
	var coords [][2]float64
	if err := cbor.Unmarshal(data, &coords); err != nil {
		return err
	}
	points := make([]geom.Point, len(coords))
	for i, c := range coords {
		points[i] = geom.NewPoint(geom.Coordinates{XY: geom.XY{X: c[0], Y: c[1]}})
	}
	mp := geom.NewMultiPoint(points)
	*m = MultiPointSF(mp)
	return nil
}

// MultiLineStringSF wraps geom.MultiLineString for CBOR marshaling.
type MultiLineStringSF geom.MultiLineString

func (m *MultiLineStringSF) MarshalCBOR() ([]byte, error) {
	if m == nil {
		return cbor.Marshal(nil)
	}
	mls := geom.MultiLineString(*m)
	numLines := mls.NumLineStrings()
	lines := make([][][2]float64, numLines)
	for i := 0; i < numLines; i++ {
		ls := mls.LineStringN(i)
		seq := ls.Coordinates()
		n := seq.Length()
		coords := make([][2]float64, n)
		for j := 0; j < n; j++ {
			xy := seq.GetXY(j)
			coords[j] = [2]float64{xy.X, xy.Y}
		}
		lines[i] = coords
	}
	raw, err := cbor.Marshal(lines)
	if err != nil {
		return nil, err
	}
	return cbor.Marshal(cbor.RawTag{Number: tagSFGeometryMultiLine, Content: raw})
}

func (m *MultiLineStringSF) UnmarshalCBOR(data []byte) error {
	var lines [][][2]float64
	if err := cbor.Unmarshal(data, &lines); err != nil {
		return err
	}
	lineStrings := make([]geom.LineString, len(lines))
	for i, line := range lines {
		floats := make([]float64, len(line)*2)
		for j, c := range line {
			floats[j*2] = c[0]
			floats[j*2+1] = c[1]
		}
		lineStrings[i] = geom.NewLineString(geom.NewSequence(floats, geom.DimXY))
	}
	mls := geom.NewMultiLineString(lineStrings)
	*m = MultiLineStringSF(mls)
	return nil
}

// MultiPolygonSF wraps geom.MultiPolygon for CBOR marshaling.
type MultiPolygonSF geom.MultiPolygon

func (m *MultiPolygonSF) MarshalCBOR() ([]byte, error) {
	if m == nil {
		return cbor.Marshal(nil)
	}
	mpoly := geom.MultiPolygon(*m)
	numPolys := mpoly.NumPolygons()
	polys := make([][][][2]float64, numPolys)
	for i := 0; i < numPolys; i++ {
		poly := mpoly.PolygonN(i)
		numHoles := poly.NumInteriorRings()
		rings := make([][][2]float64, 1+numHoles)

		extRing := poly.ExteriorRing()
		extSeq := extRing.Coordinates()
		extN := extSeq.Length()
		extCoords := make([][2]float64, extN)
		for j := 0; j < extN; j++ {
			xy := extSeq.GetXY(j)
			extCoords[j] = [2]float64{xy.X, xy.Y}
		}
		rings[0] = extCoords

		for h := 0; h < numHoles; h++ {
			hole := poly.InteriorRingN(h)
			holeSeq := hole.Coordinates()
			holeN := holeSeq.Length()
			holeCoords := make([][2]float64, holeN)
			for j := 0; j < holeN; j++ {
				xy := holeSeq.GetXY(j)
				holeCoords[j] = [2]float64{xy.X, xy.Y}
			}
			rings[1+h] = holeCoords
		}
		polys[i] = rings
	}
	raw, err := cbor.Marshal(polys)
	if err != nil {
		return nil, err
	}
	return cbor.Marshal(cbor.RawTag{Number: tagSFGeometryMultiPolygon, Content: raw})
}

func (m *MultiPolygonSF) UnmarshalCBOR(data []byte) error {
	var polys [][][][2]float64
	if err := cbor.Unmarshal(data, &polys); err != nil {
		return err
	}
	polygons := make([]geom.Polygon, len(polys))
	for i, poly := range polys {
		rings := make([]geom.LineString, len(poly))
		for j, ring := range poly {
			floats := make([]float64, len(ring)*2)
			for k, c := range ring {
				floats[k*2] = c[0]
				floats[k*2+1] = c[1]
			}
			rings[j] = geom.NewLineString(geom.NewSequence(floats, geom.DimXY))
		}
		polygons[i] = geom.NewPolygon(rings)
	}
	mpoly := geom.NewMultiPolygon(polygons)
	*m = MultiPolygonSF(mpoly)
	return nil
}

// CollectionSF wraps geom.GeometryCollection for CBOR marshaling.
type CollectionSF geom.GeometryCollection

func (c *CollectionSF) MarshalCBOR() ([]byte, error) {
	if c == nil {
		return cbor.Marshal(nil)
	}
	gc := geom.GeometryCollection(*c)
	n := gc.NumGeometries()
	geometries := make([]any, n)
	for i := 0; i < n; i++ {
		g := gc.GeometryN(i)
		switch {
		case g.IsPoint():
			p := PointSF(g.MustAsPoint())
			geometries[i] = &p
		case g.IsLineString():
			l := LineStringSF(g.MustAsLineString())
			geometries[i] = &l
		case g.IsPolygon():
			p := PolygonSF(g.MustAsPolygon())
			geometries[i] = &p
		case g.IsMultiPoint():
			m := MultiPointSF(g.MustAsMultiPoint())
			geometries[i] = &m
		case g.IsMultiLineString():
			m := MultiLineStringSF(g.MustAsMultiLineString())
			geometries[i] = &m
		case g.IsMultiPolygon():
			m := MultiPolygonSF(g.MustAsMultiPolygon())
			geometries[i] = &m
		}
	}
	raw, err := cbor.Marshal(geometries)
	if err != nil {
		return nil, err
	}
	return cbor.Marshal(cbor.RawTag{Number: tagSFGeometryCollection, Content: raw})
}

func (c *CollectionSF) UnmarshalCBOR(data []byte) error {
	var geometries []cbor.RawMessage
	if err := cbor.Unmarshal(data, &geometries); err != nil {
		return err
	}
	geoms := make([]geom.Geometry, 0, len(geometries))
	for _, raw := range geometries {
		var tag cbor.RawTag
		if err := cbor.Unmarshal(raw, &tag); err != nil {
			continue
		}
		switch tag.Number {
		case tagSFGeometryPoint:
			var p PointSF
			if err := cbor.Unmarshal(tag.Content, &p); err == nil {
				geoms = append(geoms, geom.Point(p).AsGeometry())
			}
		case tagSFGeometryLine:
			var l LineStringSF
			if err := cbor.Unmarshal(tag.Content, &l); err == nil {
				geoms = append(geoms, geom.LineString(l).AsGeometry())
			}
		case tagSFGeometryPolygon:
			var p PolygonSF
			if err := cbor.Unmarshal(tag.Content, &p); err == nil {
				geoms = append(geoms, geom.Polygon(p).AsGeometry())
			}
		case tagSFGeometryMultiPoint:
			var m MultiPointSF
			if err := cbor.Unmarshal(tag.Content, &m); err == nil {
				geoms = append(geoms, geom.MultiPoint(m).AsGeometry())
			}
		case tagSFGeometryMultiLine:
			var m MultiLineStringSF
			if err := cbor.Unmarshal(tag.Content, &m); err == nil {
				geoms = append(geoms, geom.MultiLineString(m).AsGeometry())
			}
		case tagSFGeometryMultiPolygon:
			var m MultiPolygonSF
			if err := cbor.Unmarshal(tag.Content, &m); err == nil {
				geoms = append(geoms, geom.MultiPolygon(m).AsGeometry())
			}
		}
	}
	gc := geom.NewGeometryCollection(geoms)
	*c = CollectionSF(gc)
	return nil
}
