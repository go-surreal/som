//go:build embed

package repo

import (
	"context"
	"errors"
	"fmt"
	"strings"

	som "{{.GenerateOutPath}}"
	"{{.GenerateOutPath}}/internal"
	"github.com/surrealdb/surrealdb.go/pkg/models"
	"golang.org/x/sync/singleflight"
)

// cacheInitGroup deduplicates concurrent cache initialization requests.
var cacheInitGroup singleflight.Group

// N is a placeholder for the node type.
// C is a placeholder for the conversion type.
type repo[N any, C any] struct {
	db Database

	name     string
	convFrom func(*N) *C
	convTo   func(*C) *N
}

func (r *repo[N, C]) create(ctx context.Context, node *N) error {
	data := r.convFrom(node)
	raw, err := r.db.Create(ctx, newULID(r.name), data) // TODO: make ID type configurable
	if err != nil {
		return fmt.Errorf("could not create entity: %w", err)
	}
	var conv *C
	err = r.db.Unmarshal(raw, &conv)
	if err != nil {
		return fmt.Errorf("could not unmarshal response: %w", err)
	}
	*node = *r.convTo(conv)
	return nil
}

func (r *repo[N, C]) createWithID(ctx context.Context, id string, node *N) error {
	data := r.convFrom(node)
	res, err := r.db.Create(ctx, models.NewRecordID(r.name, id), data)
	if err != nil {
		return fmt.Errorf("could not create entity: %w", err)
	}
	var conv *C
	err = r.db.Unmarshal(res, &conv)
	if err != nil {
		return fmt.Errorf("could not unmarshal entity: %w", err)
	}
	*node = *r.convTo(conv)
	return nil
}

func (r *repo[N, C]) read(ctx context.Context, id *ID) (*N, bool, error) {
	res, err := r.db.Select(ctx, id)
	if err != nil {
		return nil, false, fmt.Errorf("could not read entity: %w", err)
	}
	var conv *C
	err = r.db.Unmarshal(res, &conv)
	if err != nil {
		return nil, false, fmt.Errorf("could not unmarshal entity: %w", err)
	}
	return r.convTo(conv), true, nil
}

func (r *repo[N, C]) update(ctx context.Context, id *ID, node *N) error {
	data := r.convFrom(node)
	res, err := r.db.Update(ctx, id, data)
	if err != nil {
		if strings.Contains(err.Error(), "optimistic_lock_failed") {
			return som.ErrOptimisticLock
		}
		return fmt.Errorf("could not update entity: %w", err)
	}
	var conv *C
	err = r.db.Unmarshal(res, &conv)
	if err != nil {
		return fmt.Errorf("could not unmarshal entity: %w", err)
	}
	*node = *r.convTo(conv)
	return nil
}

func (r *repo[N, C]) delete(ctx context.Context, id *ID, node *N) error {
	_, err := r.db.Delete(ctx, id)
	if err != nil {
		return fmt.Errorf("could not delete entity: %w", err)
	}
	return nil
}

func (r *repo[N, C]) refresh(ctx context.Context, id *models.RecordID, node *N) error {
	read, exists, err := r.read(ctx, id)
	if err != nil {
		return fmt.Errorf("failed to read node: %w", err)
	}

	if !exists {
		return errors.New("given node does not exist")
	}

	*node = *read

	return nil
}

// readWithCache attempts to read from cache first, falling back to DB if needed.
// If cache is in eager mode and record not found, returns (nil, false, nil).
// If cache is in lazy mode and record not found, queries DB and populates cache.
func (r *repo[N, C]) readWithCache(ctx context.Context, id *ID, c *cache[N]) (*N, bool, error) {
	if c == nil {
		return r.read(ctx, id)
	}

	idStr := id.String()

	if record, found := c.get(idStr); found {
		return record, true, nil
	}

	if c.isEager() && c.isLoaded() {
		return nil, false, nil
	}

	record, exists, err := r.read(ctx, id)
	if err != nil {
		return nil, false, err
	}

	if exists && record != nil {
		c.set(idStr, record)
	}

	return record, exists, nil
}

// cacheResult wraps the result of cache initialization for singleflight.
type cacheResult[N any] struct {
	cache *cache[N]
	err   error
}

// getOrCreateCache returns the cache for the given model type, creating it if needed.
// The idFunc is used for eager cache population.
// The queryAll function loads all records for eager mode.
// The countAll function counts records to check against maxSize.
// Returns ErrCacheAlreadyCleaned if the cache was previously cleaned up.
func getOrCreateCache[N som.Model](
	ctx context.Context,
	idFunc func(*N) string,
	queryAll func(context.Context) ([]*N, error),
	countAll func(context.Context) (int, error),
) (*cache[N], error) {
	if !internal.CacheEnabled[N](ctx) {
		return nil, nil
	}

	opts := internal.GetCacheOptions[N](ctx)
	if opts == nil {
		return nil, nil
	}

	cacheID := internal.GetCacheKey[N](ctx)
	if cacheID == "" {
		return nil, nil
	}

	// Check if cache entry exists (could be placeholder nil or real cache)
	cached, ok := internal.GetCache(cacheID)
	if !ok {
		// No entry = cache was cleaned up
		return nil, som.ErrCacheAlreadyCleaned
	}

	// If it's already a real cache, return it
	if c, ok := cached.(*cache[N]); ok && c != nil {
		return c, nil
	}

	// Entry exists but is placeholder (nil) - need to create real cache
	var mode cacheMode
	switch opts.Mode {
	case internal.CacheModeEager:
		mode = cacheModeEager
	default:
		mode = cacheModeLazy
	}

	// Use singleflight to deduplicate concurrent cache initialization
	result, _, _ := cacheInitGroup.Do(cacheID, func() (any, error) {
		// Re-check if another goroutine already created the cache
		if cached, ok := internal.GetCache(cacheID); ok {
			if c, ok := cached.(*cache[N]); ok && c != nil {
				return &cacheResult[N]{cache: c}, nil
			}
		} else {
			// Cache was cleaned up while we were waiting
			return &cacheResult[N]{err: som.ErrCacheAlreadyCleaned}, nil
		}

		var c *cache[N]
		if mode == cacheModeLazy {
			c = newCache[N](mode, opts.TTL, opts.MaxSize)
		} else {
			// Eager mode: load all records
			count, err := countAll(ctx)
			if err != nil {
				return &cacheResult[N]{err: fmt.Errorf("could not count records for eager cache: %w", err)}, nil
			}

			if count > opts.MaxSize {
				return &cacheResult[N]{err: som.ErrCacheSizeLimitExceeded}, nil
			}

			records, err := queryAll(ctx)
			if err != nil {
				return &cacheResult[N]{err: fmt.Errorf("could not load records for eager cache: %w", err)}, nil
			}

			c = newCacheWithAll(records, idFunc, opts.TTL)
		}

		internal.SetCache(cacheID, c)
		return &cacheResult[N]{cache: c}, nil
	})

	res := result.(*cacheResult[N])
	return res.cache, res.err
}
