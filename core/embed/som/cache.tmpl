//go:build embed

package som

import (
	"context"

	"{{.GenerateOutPath}}/internal"
)

// ErrCacheSizeLimitExceeded is returned when eager cache would exceed the max size.
var ErrCacheSizeLimitExceeded = internal.ErrCacheSizeLimitExceeded

// ErrCacheAlreadyCleaned is returned when attempting to use a cache that has
// already been cleaned up via the cleanup function returned by WithCache.
var ErrCacheAlreadyCleaned = internal.ErrCacheAlreadyCleaned

// Lazy sets the cache to lazy loading mode (default).
// Records are fetched from the database on first access and cached.
var Lazy = internal.Lazy

// Eager sets the cache to eager loading mode.
// All records are loaded on first Read() call.
var Eager = internal.Eager

// WithTTL sets the time-to-live for cached data.
// In lazy mode, each entry expires individually after the given duration.
// In eager mode, the entire cache is refreshed after the given duration.
var WithTTL = internal.WithTTL

// WithMaxSize sets the maximum number of records for eager cache.
// Default is 1000. If the table has more records than maxSize,
// ErrCacheSizeLimitExceeded is returned.
var WithMaxSize = internal.WithMaxSize

// CacheOption is a functional option for configuring cache behavior.
type CacheOption = internal.CacheOption

// WithCache enables caching for the specified model type.
// Returns the context with cache enabled and a cleanup function.
// The cleanup function should be called when the cache is no longer needed,
// typically via defer.
//
// After the cleanup function is called, any attempt to use the returned context
// for cached reads will return ErrCacheAlreadyCleaned. This prevents accidental
// use of stale cache references.
//
// For eager caching, WithMaxSize limits the number of records that can be cached.
// If the table exceeds MaxSize, Read returns ErrCacheSizeLimitExceeded.
// This check happens both during initial cache load and during TTL-based refresh.
//
// Example:
//
//	ctx, cleanup := som.WithCache[model.Group](ctx)
//	defer cleanup()
//
//	ctx, cleanup := som.WithCache[model.Group](ctx, som.Lazy())          // explicit lazy
//	ctx, cleanup := som.WithCache[model.Group](ctx, som.Eager())         // eager, load on first read
//	ctx, cleanup := som.WithCache[model.Group](ctx, som.WithTTL(5*time.Minute))  // with expiration
//	ctx, cleanup := som.WithCache[model.Group](ctx, som.Eager(), som.WithMaxSize(5000))
func WithCache[T Model](ctx context.Context, opts ...CacheOption) (context.Context, func()) {
	options := &internal.CacheOptions{
		Mode:    internal.CacheModeLazy,
		MaxSize: internal.DefaultMaxSize,
	}
	for _, opt := range opts {
		opt(options)
	}

	id := internal.NextCacheID()
	internal.InitCache(id, nil) // Initialize placeholder to track active cache
	ctx = internal.SetCacheContext[T](ctx, id, options)

	cleanup := func() {
		internal.DropCacheByID(id)
	}

	return ctx, cleanup
}
