package embed

import (
	"bytes"
	"embed"
	"io/fs"
	"path/filepath"
	"strings"
	"text/template"
)

const (
	baseDir = "som"
)

var (
	CodegenComment = []byte("// Code generated by github.com/go-surreal/som, DO NOT EDIT.")
	embedComment   = []byte("//go:build embed")
)

//go:embed som
var content embed.FS

type Template struct {
	GenerateOutPath      string
	UsesGoogleUUID       bool
	UsesGofrsUUID        bool
	UsesOrbGeo           bool
	UsesSimplefeaturesGeo bool
	UsesGoGeomGeo        bool
}

// FileCondition specifies when a file should be included in the output.
type FileCondition int

const (
	FileAlways FileCondition = iota
	FileIfGoogleUUID
	FileIfGofrsUUID
	FileIfOrbGeo
	FileIfSimplefeaturesGeo
	FileIfGoGeomGeo
)

// fileConditions maps output file paths to their inclusion conditions.
var fileConditions = map[string]FileCondition{
	"internal/types/uuid_google.go":              FileIfGoogleUUID,
	"internal/types/uuid_gofrs.go":               FileIfGofrsUUID,
	"internal/lib/filter.uuid_google.go":         FileIfGoogleUUID,
	"internal/lib/filter.uuid_gofrs.go":          FileIfGofrsUUID,
	"internal/cbor/helpers_uuid_google.go":       FileIfGoogleUUID,
	"internal/cbor/helpers_uuid_gofrs.go":        FileIfGofrsUUID,
	"internal/distinct/distinct_uuid_google.go":  FileIfGoogleUUID,
	"internal/distinct/distinct_uuid_gofrs.go":   FileIfGofrsUUID,
	// Geo files - orb
	"internal/types/geo_orb.go":        FileIfOrbGeo,
	"internal/lib/filter.geo_orb.go":   FileIfOrbGeo,
	"internal/cbor/helpers_geo_orb.go": FileIfOrbGeo,
	// Geo files - simplefeatures
	"internal/types/geo_sf.go":        FileIfSimplefeaturesGeo,
	"internal/lib/filter.geo_sf.go":   FileIfSimplefeaturesGeo,
	"internal/cbor/helpers_geo_sf.go": FileIfSimplefeaturesGeo,
	// Geo files - go-geom
	"internal/types/geo_gogeom.go":        FileIfGoGeomGeo,
	"internal/lib/filter.geo_gogeom.go":   FileIfGoGeomGeo,
	"internal/cbor/helpers_geo_gogeom.go": FileIfGoGeomGeo,
}

type File struct {
	Path    string
	Content []byte
}

func Read(tmpl *Template) ([]*File, error) {
	var files []*File

	buf := bytes.NewBuffer(nil)

	err := fs.WalkDir(content, baseDir, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}

		if d.IsDir() {
			return nil
		}

		// Compute output path early to check conditions
		outputPath := strings.TrimPrefix(path, baseDir+string(filepath.Separator))
		if strings.HasSuffix(outputPath, ".go.tmpl") {
			outputPath = strings.TrimSuffix(outputPath, ".tmpl")
		}

		// Check if file should be included based on condition
		if condition, hasCondition := fileConditions[outputPath]; hasCondition {
			switch condition {
			case FileIfGoogleUUID:
				if !tmpl.UsesGoogleUUID {
					return nil // Skip this file
				}
			case FileIfGofrsUUID:
				if !tmpl.UsesGofrsUUID {
					return nil // Skip this file
				}
			case FileIfOrbGeo:
				if !tmpl.UsesOrbGeo {
					return nil // Skip this file
				}
			case FileIfSimplefeaturesGeo:
				if !tmpl.UsesSimplefeaturesGeo {
					return nil // Skip this file
				}
			case FileIfGoGeomGeo:
				if !tmpl.UsesGoGeomGeo {
					return nil // Skip this file
				}
			}
		}

		file, err := fs.ReadFile(content, path)
		if err != nil {
			return err
		}

		fileTmpl, err := template.New(path).Parse(string(file))
		if err != nil {
			return err
		}

		if err := fileTmpl.Execute(buf, tmpl); err != nil {
			return err
		}

		defer buf.Reset()

		files = append(files, &File{
			Path:    outputPath,
			Content: bytes.Replace(buf.Bytes(), embedComment, CodegenComment, 1),
		})

		return nil
	})
	if err != nil {
		return nil, err
	}

	return files, nil
}
