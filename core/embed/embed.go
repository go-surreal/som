package embed

import (
	"bytes"
	"embed"
	"io/fs"
	"path/filepath"
	"strings"
	"text/template"
)

const (
	baseDir = "som"
)

var (
	CodegenComment = []byte("// Code generated by github.com/go-surreal/som, DO NOT EDIT.")
	embedComment   = []byte("//go:build embed")
)

//go:embed som
var content embed.FS

type Template struct {
	GenerateOutPath string
	UsesGoogleUUID  bool
	UsesGofrsUUID   bool
}

// FileCondition specifies when a file should be included in the output.
type FileCondition int

const (
	FileAlways FileCondition = iota
	FileIfGoogleUUID
	FileIfGofrsUUID
)

// fileConditions maps output file paths to their inclusion conditions.
var fileConditions = map[string]FileCondition{
	"internal/types/uuid_google.go":        FileIfGoogleUUID,
	"internal/types/uuid_gofrs.go":         FileIfGofrsUUID,
	"internal/lib/filter.uuid_google.go":   FileIfGoogleUUID,
	"internal/lib/filter.uuid_gofrs.go":    FileIfGofrsUUID,
	"internal/cbor/helpers_uuid_google.go": FileIfGoogleUUID,
	"internal/cbor/helpers_uuid_gofrs.go":  FileIfGofrsUUID,
}

type File struct {
	Path    string
	Content []byte
}

func Read(tmpl *Template) ([]*File, error) {
	var files []*File

	buf := bytes.NewBuffer(nil)

	err := fs.WalkDir(content, baseDir, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}

		if d.IsDir() {
			return nil
		}

		// Compute output path early to check conditions
		outputPath := strings.TrimPrefix(path, baseDir+string(filepath.Separator))
		if strings.HasSuffix(outputPath, ".tmpl") {
			outputPath = strings.TrimSuffix(outputPath, ".tmpl") + ".go"
		}

		// Check if file should be included based on condition
		if condition, hasCondition := fileConditions[outputPath]; hasCondition {
			switch condition {
			case FileIfGoogleUUID:
				if !tmpl.UsesGoogleUUID {
					return nil // Skip this file
				}
			case FileIfGofrsUUID:
				if !tmpl.UsesGofrsUUID {
					return nil // Skip this file
				}
			}
		}

		file, err := fs.ReadFile(content, path)
		if err != nil {
			return err
		}

		fileTmpl, err := template.New(path).Parse(string(file))
		if err != nil {
			return err
		}

		if err := fileTmpl.Execute(buf, tmpl); err != nil {
			return err
		}

		defer buf.Reset()

		files = append(files, &File{
			Path:    outputPath,
			Content: bytes.Replace(buf.Bytes(), embedComment, CodegenComment, 1),
		})

		return nil
	})
	if err != nil {
		return nil, err
	}

	return files, nil
}
