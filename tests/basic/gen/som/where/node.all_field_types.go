// Code generated by github.com/go-surreal/som, DO NOT EDIT.
package where

import (
	lib "github.com/go-surreal/som/tests/basic/gen/som/internal/lib"
	model "github.com/go-surreal/som/tests/basic/model"
	uuid "github.com/google/uuid"
	"net/url"
	"time"
)

var AllFieldTypes = newAllFieldTypes[model.AllFieldTypes](lib.NewKey[model.AllFieldTypes]())

func newAllFieldTypes[T any](key lib.Key[T]) allFieldTypes[T] {
	return allFieldTypes[T]{
		Bool:               lib.NewBool[T](lib.Field(key, "bool")),
		BoolPtr:            lib.NewBoolPtr[T](lib.Field(key, "bool_ptr")),
		BoolSlice:          lib.NewSliceMaker[T, bool, *lib.Bool[T]](lib.NewBool[T])(lib.Field(key, "bool_slice")),
		Byte:               lib.NewBase[T, byte](lib.Field(key, "byte")),
		BytePtr:            lib.NewBasePtr[T, byte](lib.Field(key, "byte_ptr")),
		ByteSlice:          lib.NewByteSlice[T](lib.Field(key, "byte_slice")),
		ByteSlicePtr:       lib.NewByteSlice[T](lib.Field(key, "byte_slice_ptr")),
		CreatedAt:          lib.NewTime[T](lib.Field(key, "created_at")),
		Duration:           lib.NewDuration[T](lib.Field(key, "duration")),
		DurationNil:        lib.NewDurationPtr[T](lib.Field(key, "duration_nil")),
		DurationPtr:        lib.NewDurationPtr[T](lib.Field(key, "duration_ptr")),
		DurationSlice:      lib.NewSliceMaker[T, time.Duration, *lib.Duration[T]](lib.NewDuration[T])(lib.Field(key, "duration_slice")),
		EnumPtr:            lib.NewBasePtr[T, model.Role](lib.Field(key, "enum_ptr")),
		EnumPtrSlice:       lib.NewSlice[T, model.Role](lib.Field(key, "enum_ptr_slice"), lib.NewBasePtr[T, model.Role]),
		EnumPtrSlicePtr:    lib.NewSlice[T, model.Role](lib.Field(key, "enum_ptr_slice_ptr"), lib.NewBasePtr[T, model.Role]),
		Float32:            lib.NewNumeric[T, float32](lib.Field(key, "float_32")),
		Float32PtrSlice:    lib.NewSliceMaker[T, *float32, *lib.NumericPtr[T, *float32]](lib.NewNumericPtr[T, *float32])(lib.Field(key, "float_32_ptr_slice")),
		Float32PtrSlicePtr: lib.NewSliceMaker[T, *float32, *lib.NumericPtr[T, *float32]](lib.NewNumericPtr[T, *float32])(lib.Field(key, "float_32_ptr_slice_ptr")),
		Float32Slice:       lib.NewSliceMaker[T, float32, *lib.Numeric[T, float32]](lib.NewNumeric[T, float32])(lib.Field(key, "float_32_slice")),
		Float32SlicePtr:    lib.NewSliceMaker[T, float32, *lib.Numeric[T, float32]](lib.NewNumeric[T, float32])(lib.Field(key, "float_32_slice_ptr")),
		Float64:            lib.NewNumeric[T, float64](lib.Field(key, "float_64")),
		GroupsSlice:        lib.NewSliceMaker[T, []model.Group, groupSlice[T]]()(lib.Field(key, "groups_slice")),
		ID:                 lib.NewID[T](lib.Field(key, "id"), "all_field_types"),
		Int:                lib.NewNumeric[T, int](lib.Field(key, "int")),
		Int16:              lib.NewNumeric[T, int16](lib.Field(key, "int_16")),
		Int16Ptr:           lib.NewNumericPtr[T, *int16](lib.Field(key, "int_16_ptr")),
		Int32:              lib.NewNumeric[T, int32](lib.Field(key, "int_32")),
		Int32Ptr:           lib.NewNumericPtr[T, *int32](lib.Field(key, "int_32_ptr")),
		Int64:              lib.NewNumeric[T, int64](lib.Field(key, "int_64")),
		Int64Ptr:           lib.NewNumericPtr[T, *int64](lib.Field(key, "int_64_ptr")),
		Int8:               lib.NewNumeric[T, int8](lib.Field(key, "int_8")),
		Int8Ptr:            lib.NewNumericPtr[T, *int8](lib.Field(key, "int_8_ptr")),
		IntPtr:             lib.NewNumericPtr[T, *int](lib.Field(key, "int_ptr")),
		IntPtrSlice:        lib.NewSliceMaker[T, *int, *lib.NumericPtr[T, *int]](lib.NewNumericPtr[T, *int])(lib.Field(key, "int_ptr_slice")),
		IntPtrSlicePtr:     lib.NewSliceMaker[T, *int, *lib.NumericPtr[T, *int]](lib.NewNumericPtr[T, *int])(lib.Field(key, "int_ptr_slice_ptr")),
		IntSlice:           lib.NewSliceMaker[T, int, *lib.Numeric[T, int]](lib.NewNumeric[T, int])(lib.Field(key, "int_slice")),
		IntSlicePtr:        lib.NewSliceMaker[T, int, *lib.Numeric[T, int]](lib.NewNumeric[T, int])(lib.Field(key, "int_slice_ptr")),
		Other:              lib.NewSliceMaker[T, string, *lib.String[T]](lib.NewString[T])(lib.Field(key, "other")),
		Role:               lib.NewBase[T, model.Role](lib.Field(key, "role")),
		Roles:              lib.NewSlice[T, model.Role](lib.Field(key, "roles"), lib.NewBase[T, model.Role]),
		Rune:               lib.NewNumeric[T, rune](lib.Field(key, "rune")),
		RuneSlice:          lib.NewSliceMaker[T, rune, *lib.Numeric[T, rune]](lib.NewNumeric[T, rune])(lib.Field(key, "rune_slice")),
		SliceSlice:         lib.NewSliceMaker[T, []string, *lib.Slice[T, string, *lib.String[T]]](lib.NewSliceMaker[T, string, *lib.String[T]](lib.NewString[T]))(lib.Field(key, "slice_slice")),
		SliceSliceSlice:    lib.NewSliceMaker[T, [][]string, *lib.Slice[T, []string, *lib.Slice[T, string, *lib.String[T]]]](lib.NewSliceMaker[T, []string, *lib.Slice[T, string, *lib.String[T]]](lib.NewSliceMaker[T, string, *lib.String[T]](lib.NewString[T])))(lib.Field(key, "slice_slice_slice")),
		SliceSliceSlice2:   lib.NewSliceMaker[T, [][]model.SomeStruct, *lib.Slice[T, []model.SomeStruct]](lib.NewSliceMaker[T, []model.SomeStruct]())(lib.Field(key, "slice_slice_slice_2")),
		String:             lib.NewString[T](lib.Field(key, "string")),
		StringPtr:          lib.NewStringPtr[T](lib.Field(key, "string_ptr")),
		StringPtrSlice:     lib.NewSliceMaker[T, *string, *lib.StringPtr[T]](lib.NewStringPtr[T])(lib.Field(key, "string_ptr_slice")),
		StringSlicePtr:     lib.NewSliceMaker[T, string, *lib.String[T]](lib.NewString[T])(lib.Field(key, "string_slice_ptr")),
		Time:               lib.NewTime[T](lib.Field(key, "time")),
		TimeNil:            lib.NewTimePtr[T](lib.Field(key, "time_nil")),
		TimePtr:            lib.NewTimePtr[T](lib.Field(key, "time_ptr")),
		TimeSlice:          lib.NewSliceMaker[T, time.Time, *lib.Time[T]](lib.NewTime[T])(lib.Field(key, "time_slice")),
		URL:                lib.NewURL[T](lib.Field(key, "url")),
		URLNil:             lib.NewURLPtr[T](lib.Field(key, "url_nil")),
		URLPtr:             lib.NewURLPtr[T](lib.Field(key, "url_ptr")),
		URLSlice:           lib.NewSliceMaker[T, url.URL, *lib.URL[T]](lib.NewURL[T])(lib.Field(key, "url_slice")),
		UUID:               lib.NewBaseConv[T, uuid.UUID](lib.Field(key, "uuid"), convUUID),
		UUIDNil:            lib.NewBasePtrConv[T, uuid.UUID](lib.Field(key, "uuid_nil"), convUUID),
		UUIDPtr:            lib.NewBasePtrConv[T, uuid.UUID](lib.Field(key, "uuid_ptr"), convUUID),
		UUIDSlice:          lib.NewSliceMaker[T, uuid.UUID, *lib.Base[T, uuid.UUID]](lib.NewBaseConv[T, uuid.UUID])(lib.Field(key, "uuid_slice")),
		Uint16:             lib.NewNumeric[T, uint16](lib.Field(key, "uint_16")),
		Uint16Ptr:          lib.NewNumericPtr[T, *uint16](lib.Field(key, "uint_16_ptr")),
		Uint32:             lib.NewNumeric[T, uint32](lib.Field(key, "uint_32")),
		Uint32Ptr:          lib.NewNumericPtr[T, *uint32](lib.Field(key, "uint_32_ptr")),
		Uint8:              lib.NewNumeric[T, uint8](lib.Field(key, "uint_8")),
		Uint8Ptr:           lib.NewNumericPtr[T, *uint8](lib.Field(key, "uint_8_ptr")),
		UpdatedAt:          lib.NewTime[T](lib.Field(key, "updated_at")),
		key:                key,
	}
}

type allFieldTypes[T any] struct {
	key                lib.Key[T]
	ID                 *lib.ID[T]
	CreatedAt          *lib.Time[T]
	UpdatedAt          *lib.Time[T]
	String             *lib.String[T]
	StringPtr          *lib.StringPtr[T]
	Other              *lib.Slice[T, string, *lib.String[T]]
	StringPtrSlice     *lib.Slice[T, *string, *lib.StringPtr[T]]
	StringSlicePtr     *lib.Slice[T, string, *lib.String[T]]
	Int                *lib.Numeric[T, int]
	IntPtr             *lib.NumericPtr[T, *int]
	IntSlice           *lib.Slice[T, int, *lib.Numeric[T, int]]
	IntPtrSlice        *lib.Slice[T, *int, *lib.NumericPtr[T, *int]]
	IntSlicePtr        *lib.Slice[T, int, *lib.Numeric[T, int]]
	IntPtrSlicePtr     *lib.Slice[T, *int, *lib.NumericPtr[T, *int]]
	Int8               *lib.Numeric[T, int8]
	Int8Ptr            *lib.NumericPtr[T, *int8]
	Int16              *lib.Numeric[T, int16]
	Int16Ptr           *lib.NumericPtr[T, *int16]
	Int32              *lib.Numeric[T, int32]
	Int32Ptr           *lib.NumericPtr[T, *int32]
	Int64              *lib.Numeric[T, int64]
	Int64Ptr           *lib.NumericPtr[T, *int64]
	Uint8              *lib.Numeric[T, uint8]
	Uint8Ptr           *lib.NumericPtr[T, *uint8]
	Uint16             *lib.Numeric[T, uint16]
	Uint16Ptr          *lib.NumericPtr[T, *uint16]
	Uint32             *lib.Numeric[T, uint32]
	Uint32Ptr          *lib.NumericPtr[T, *uint32]
	Float32            *lib.Numeric[T, float32]
	Float32Slice       *lib.Slice[T, float32, *lib.Numeric[T, float32]]
	Float32SlicePtr    *lib.Slice[T, float32, *lib.Numeric[T, float32]]
	Float32PtrSlice    *lib.Slice[T, *float32, *lib.NumericPtr[T, *float32]]
	Float32PtrSlicePtr *lib.Slice[T, *float32, *lib.NumericPtr[T, *float32]]
	Float64            *lib.Numeric[T, float64]
	Rune               *lib.Numeric[T, rune]
	RuneSlice          *lib.Slice[T, rune, *lib.Numeric[T, rune]]
	Bool               *lib.Bool[T]
	BoolPtr            *lib.BoolPtr[T]
	BoolSlice          *lib.Slice[T, bool, *lib.Bool[T]]
	Time               *lib.Time[T]
	TimePtr            *lib.TimePtr[T]
	TimeNil            *lib.TimePtr[T]
	TimeSlice          *lib.Slice[T, time.Time, *lib.Time[T]]
	Duration           *lib.Duration[T]
	DurationPtr        *lib.DurationPtr[T]
	DurationNil        *lib.DurationPtr[T]
	DurationSlice      *lib.Slice[T, time.Duration, *lib.Duration[T]]
	UUID               *lib.Base[T, uuid.UUID]
	UUIDPtr            *lib.BasePtr[T, uuid.UUID]
	UUIDNil            *lib.BasePtr[T, uuid.UUID]
	UUIDSlice          *lib.Slice[T, uuid.UUID, *lib.Base[T, uuid.UUID]]
	URL                *lib.URL[T]
	URLPtr             *lib.URLPtr[T]
	URLNil             *lib.URLPtr[T]
	URLSlice           *lib.Slice[T, url.URL, *lib.URL[T]]
	Role               *lib.Base[T, model.Role]
	EnumPtr            *lib.BasePtr[T, model.Role]
	Roles              *lib.Slice[T, model.Role, *lib.Base[T, model.Role]]
	EnumPtrSlice       *lib.Slice[T, model.Role, *lib.BasePtr[T, model.Role]]
	EnumPtrSlicePtr    *lib.Slice[T, model.Role, *lib.BasePtr[T, model.Role]]
	GroupsSlice        *lib.Slice[T, []model.Group, groupSlice[T]]
	SliceSlice         *lib.Slice[T, []string, *lib.Slice[T, string, *lib.String[T]]]
	SliceSliceSlice    *lib.Slice[T, [][]string, *lib.Slice[T, []string, *lib.Slice[T, string, *lib.String[T]]]]
	SliceSliceSlice2   *lib.Slice[T, [][]model.SomeStruct, *lib.Slice[T, []model.SomeStruct]]
	Byte               *lib.Base[T, byte]
	BytePtr            *lib.BasePtr[T, byte]
	ByteSlice          *lib.ByteSlice[T]
	ByteSlicePtr       *lib.ByteSlice[T]
}

func (n allFieldTypes[T]) Login() login[T] {
	return newLogin[T](lib.Field(n.key, "login"))
}

func (n allFieldTypes[T]) StructPtr() someStruct[T] {
	return newSomeStruct[T](lib.Field(n.key, "struct_ptr"))
}

func (n allFieldTypes[T]) StructSlice() *lib.Slice[T, model.SomeStruct, someStruct[T]] {
	return lib.NewSlice[T, model.SomeStruct, someStruct[T]](lib.Field(n.key, "struct_slice"), newSomeStruct[T])
}

func (n allFieldTypes[T]) StructPtrSlice() *lib.Slice[T, *model.SomeStruct, someStruct[T]] {
	return lib.NewSlice[T, *model.SomeStruct, someStruct[T]](lib.Field(n.key, "struct_ptr_slice"), newSomeStruct[T])
}

func (n allFieldTypes[T]) StructPtrSlicePtr() *lib.Slice[T, *model.SomeStruct, someStruct[T]] {
	return lib.NewSlice[T, *model.SomeStruct, someStruct[T]](lib.Field(n.key, "struct_ptr_slice_ptr"), newSomeStruct[T])
}

func (n allFieldTypes[T]) MainGroup() group[T] {
	return newGroup[T](lib.Field(n.key, "main_group"))
}

func (n allFieldTypes[T]) MainGroupPtr() group[T] {
	return newGroup[T](lib.Field(n.key, "main_group_ptr"))
}

func (n allFieldTypes[T]) Groups(filters ...lib.Filter[model.Group]) groupSlice[T] {
	key := lib.Node(n.key, "groups", filters)
	return groupSlice[T]{lib.KeyFilter[T](key), lib.NewSlice[T, model.Group, group[T]](key, newGroup[T])}
}

func (n allFieldTypes[T]) NodePtrSlice(filters ...lib.Filter[model.Group]) groupSlice[T] {
	key := lib.Node(n.key, "node_ptr_slice", filters)
	return groupSlice[T]{lib.KeyFilter[T](key), lib.NewSlice[T, model.Group, group[T]](key, newGroup[T])}
}

func (n allFieldTypes[T]) NodePtrSlicePtr(filters ...lib.Filter[model.Group]) groupSlice[T] {
	key := lib.Node(n.key, "node_ptr_slice_ptr", filters)
	return groupSlice[T]{lib.KeyFilter[T](key), lib.NewSlice[T, model.Group, group[T]](key, newGroup[T])}
}

func (n allFieldTypes[T]) MemberOf(filters ...lib.Filter[model.GroupMember]) groupMemberIn[T] {
	return newGroupMemberIn[T](lib.EdgeIn(n.key, "group_member", filters))
}

type allFieldTypesEdges[T any] struct {
	lib.Filter[T]
	key lib.Key[T]
}

func (n allFieldTypesEdges[T]) MemberOf(filters ...lib.Filter[model.GroupMember]) groupMemberIn[T] {
	return newGroupMemberIn[T](lib.EdgeIn(n.key, "group_member", filters))
}

type allFieldTypesSlice[T any] struct {
	lib.Filter[T]
	*lib.Slice[T, model.AllFieldTypes, allFieldTypes[T]]
}
